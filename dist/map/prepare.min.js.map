{"version":3,"sources":["prepare.js"],"names":["array","it","Array","prototype","slice","call","single","list","length","shift","attempt","mutation","subject","parameters","alternative","arguments","apply","this","inject","transform","copy","key","value","find","combine","values","index","concat","indexOf","undefined","empty","curry","method","params","callback","_len","input","_key","inputs","context","update","fetch","results","ready","enough","missing","some","negated","prepare","not","tmp","module","exports"],"mappings":"AAAA,aAUA,SAASA,MAAOC,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,OAAQC,GACf,IACIC,EAKJ,OAHAA,EAASD,EAAKC,OACM,IAAXA,EAAeD,EAAKE,QAAUF,EAiBzC,SAASG,QAASC,EAAUC,GAC1B,IAAIC,OAAAA,EACAC,OAAAA,EAQJ,OALAD,EAAab,MAAMe,WAAWX,MAAM,GACpCU,EAAcR,OAAOO,GAEVF,EAASK,MAAMC,KAAMJ,IAEbC,EAerB,SAASI,OAAQjB,EAAIkB,GACnB,IAAIC,KAUJ,IAAK,IAAIC,KAAOpB,EAAMmB,EAAKC,GAR3B,SAAgBA,EAAKC,GAKnB,OAJgB,WAAA,OAAMA,IAAUF,IAAQ,GAC3B,WAAA,MAAgB,aAAVE,GAAwBZ,QAAQS,EAAWG,IACjD,WAAA,MAAgB,WAAVA,GAAsBJ,OAAOI,EAAOH,KAEpBI,KAAK,SAAAtB,GAAA,OAAMA,SAAWqB,GAGnBD,EAAKpB,EAAGoB,IAEhD,OAAOD,EAcT,SAASI,QAASxB,EAAOyB,GACvB,IAAIC,OAAAA,EAIJ,IAFA1B,EAAQA,EAAM2B,YAEiC,KAAvCD,EAAQ1B,EAAM4B,aAAQC,KAAsBJ,EAAOjB,OAAS,GAClER,EAAM0B,GAASD,EAAOhB,QAGxB,OAAOT,EAAM2B,OAAOF,GAWtB,SAASK,MAAO7B,GACd,YAAc4B,IAAP5B,GAA2B,OAAPA,EAY7B,SAAS8B,MAAOC,GAkBd,SAASb,EAAWc,GAkBlB,SAASC,IAAoB,IAAA,IAAAC,EAAApB,UAAAP,OAAP4B,EAAOlC,MAAAiC,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAPD,EAAOC,GAAAtB,UAAAsB,GAO3B,OAJAC,EAASd,QAAQS,EAAQjC,MAAMe,YAC/BwB,EAAUC,EAAOvB,MACNwB,EAAMH,GAtBnB,IAAIA,EACAC,EAEAG,EAAU,WAAA,OAAMV,EAAOhB,MAAMuB,EAASD,IACtCE,EAAS,SAAAvC,GAAA,OAAMsC,GAAWtC,GAC1BwC,EAAQ,SAAAxC,GAAA,OAAO0C,EAAM1C,GAAsByC,IAAhBvB,EAAUlB,IAEzC,OAAOiC,EAzBT,IAAIU,EAAS,SAAAR,GAAA,OAASA,EAAM5B,OAASwB,EAAOxB,QACxCqC,EAAU,SAAAT,GAAA,OAASA,EAAMU,KAAKhB,QAC9Ba,EAAQ,SAAA1C,GAAA,OAAM2C,EAAO3C,KAAQ4C,EAAQ5C,IAEzC,OAAO+B,EAAOxB,QAAU,EAAIwB,EAASb,MAoDvC,SAAS4B,QAAS9C,GAChB,OAAO,WACL,OAAQA,EAAGe,MAAMC,KAAMF,YAiB3B,SAASiC,QAAS/C,GAChB,IAAIgD,OAAAA,EAAJC,OAASA,EAQT,OANAD,EAAM/B,OAAOjB,EAAI8C,SACjBE,EAAM/B,OAAO+B,EAAKlB,OAClBmB,EAAMhC,OAAOjB,EAAI8B,OAEjBmB,EAAID,IAAMA,EAEHC,EAGTC,OAAOC,QAAUJ","file":"../dist/prepare.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {};\r\n\r\n  function cycle (key, value) {\r\n    let duplicate = () => value === copy && false;\r\n    let effort = () => value === 'function' && attempt(transform, value);\r\n    let needle = () => value === 'object' && inject(value, transform);\r\n\r\n    return [duplicate, effort, needle].find(it => it())() || value\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]); }\r\n\r\n  return copy\r\n}\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\n\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp;\r\n\r\n  not = inject(it, negated);\r\n  not = inject(not, curry);\r\n  tmp = inject(it, curry);\r\n\r\n  tmp.not = not;\r\n\r\n  return tmp\r\n}\n\nmodule.exports = prepare;\n"]}