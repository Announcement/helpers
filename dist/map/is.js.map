{"version":3,"sources":["is.js"],"names":["similar","reference","object","typesMatch","constructorsMatch","constructor","equal","exists","it","undefined","array","Array","prototype","slice","call","single","list","result","isArray","alone","length","shift","attempt","mutation","subject","parameters","apply","method","valid","arguments","inject","transform","copy","keys","isObject","name","isFunction","forObject","forFunction","Object","forEach","key","value","combine","values","index","concat","indexOf","empty","curry","enough","input","missing","some","ready","inputs","context","results","update","fetch","callback","response","negated","prepare","not","tmp","inside","haystack","needle","toValues","map","areInside","insideArray","insideObject","matches","search","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","element","nodeType","fragment","text","is","existent","module","exports"],"mappings":"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","file":"../is.js","sourcesContent":["'use strict';\n\n/**\r\n * Check if they're similar in origin (type & constructor).\r\n *\r\n * @function similar\r\n *\r\n * @param {Object} reference - For comparison reference.\r\n * @param {Object} object - To be compared.\r\n *\r\n * @returns {boolean} True if they have the same type and constructor.\r\n */\nfunction similar (reference, object) {\n  let typesMatch;\n  let constructorsMatch;\n\n  constructorsMatch = reference.constructor === object.constructor;\n  typesMatch = typeof reference === typeof object;\n\n  return typesMatch && constructorsMatch\n}\n\n// import has from './has' // hasOwnProperty\n// import pair from './pair' // {key: value} => [{key: key, value: value}]\n// import flatten from './flatten' // [[[[1]], 2]] => [1, 2]\nvar equal = function (reference, object) {\n  if (!similar(reference, object)) {\n    return false\n  }\n\n  // if (reference.constructor !== Object) {\n  //   return reference === object\n  // }\n\n  // return flatten([\n  //   pair(reference),\n  //   pair(object)\n  // ])\n  // .every(item => {\n  //   return has(reference)(item.key) &&\n  //     has(object)(item.key) &&\n  //     equals(reference[item.key], object[item.key])\n  // })\n};\n\n// function equals (r, o) {\n//   // Are they of the same type?\n//   if (typeof r !== typeof o || r.constructor !== o.constructor) {\n//     return false\n//   }\n//\n//   // Do we need to check recursively?\n//   if (r.constructor !== Object) {\n//     return r === o\n//   }\n//\n//   return flatten([\n//     pair(r),\n//     pair(o)\n//   ])\n//   .every(item => {\n//     return has(r)(item.key) &&\n//       has(o)(item.key) &&\n//       equals(r[item.key], o[item.key])\n//   })\n// }\n//\n// export default equals\n\n\n\n// export default function () {\n//   // this is done to prevent scope/global leakage\n//   return equals.apply(this, arguments)\n//\n//   /**\n//    * Compares reference object to another object.\n//    *\n//    * @function equals\n//    *\n//    * @see has\n//    * @see pair\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - That matches the reference.\n//    *\n//    * @returns {boolean} True, unless they are not equal.\n//    */\n//   function equals (reference, object) {\n//     return similar(reference, object) && identical(reference, object)\n//   }\n//\n//   /**\n//    * Checks to see if two items of the same type and class are the same.\n//    *\n//    * @function identical\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - A similar object to the reference.\n//    *\n//    * @returns {boolean} True, unless reference, object are different type or constructor.\n//    */\n//   function identical (reference, object) {\n//     return test() || pairs()\n//\n//     function test () {\n//       let isObject = () => reference.constructor === Object\n//       let isEqual = () => reference === object\n//\n//       return !isObject() && isEqual()\n//     }\n//\n//     function pairs () {\n//       let asPair = it => pair(it)\n//       let array = [reference, object].map(asPair)\n//\n//       return flatten(array).every(every)\n//     }\n//\n//     function every (item) {\n//       let both = it => has(reference)(it) && has(object)(it)\n//       let match = it => equals(reference[it], object[it])\n//\n//       return !both(item.key) || match(item.key)\n//     }\n//   }\n// }\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\n/**\n * Injects a transformer into each element of a collection.\n *\n * @function inject\n *\n * @see attempt\n *\n * @param {Object.<string, Function>} it - Collection of functions.\n * @param {Function} transform - Mutator function to run through each of the functions in it.\n *\n * @returns {Object.<string, Function>} All it functions, but mutated via transform.\n */\nfunction inject (it, transform) {\n  var copy;\n  var keys;\n\n  let isObject = it =>\n    typeof it === 'object' && it.constructor.name === 'Object';\n\n  let isFunction = it =>\n    typeof it === 'function' && it.constructor.name === 'Function';\n\n  let forObject = it =>\n    isObject(it) && inject(it, transform);\n\n  let forFunction = it =>\n    isFunction(it) && attempt(transform, it);\n\n  keys = Object.keys(it);\n  copy = {};\n\n  keys.forEach(forEach);\n\n  return copy\n\n  function forEach (key) {\n    var value;\n\n    value = it[key];\n\n    value = attempt(forObject, value);\n    value = attempt(forFunction, value);\n\n    copy[key] = value;\n  }\n}\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end.\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - List of existing items.\r\n * @param {Array} values - Proposed additions to the list.\r\n *\r\n * @returns {Array} - Collective array.\r\n */\nvar combine = function (array, values) {\n  let index;\n\n  array = array.concat([]);\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift();\n  }\n\n  return array.concat(values)\n};\n\n/**\r\n * Check to see if an item is null or undefined.\r\n *\r\n * @function empty\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} False, unless it is null or undefiend.\r\n */\nvar empty = function (it) {\n  return it === undefined || it === null\n};\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nvar curry = function (method) {\n  let enough = input => input.length >= method.length;\n  let missing = input => input.some(empty);\n  let ready = it => enough(it) && !missing(it);\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs;\n    var context;\n\n    let results = () => method.apply(context, inputs);\n    let update = it => context || it;\n    let fetch = it => !ready(it) ? transform(it) : results();\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response;\n\n      inputs = combine(parameters, array(arguments));\n      context = update(this);\n      response = fetch(inputs);\n\n      return response\n    }\n  }\n};\n\n/**\r\n * Returns a modified version of a function with negated boolean output.\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - Method to be negated.\r\n *\r\n * @returns {Function} Function with inverse output.\r\n */\nfunction negated (it) {\n  return function () {\n    return !it.apply(this, arguments)\n  }\n}\n\nfunction prepare (it) {\n  var not;\n  var tmp;\n\n  not = inject(it, negated);\n  not = inject(not, curry);\n  tmp = inject(it, curry);\n\n  tmp.not = not;\n\n  return tmp\n}\n\n/**\r\n * Detects if the needle is in the haystack.\r\n *\r\n * @function inside\r\n *\r\n * @param {Object|Array} haystack - What we are looking in.\r\n * @param {Object} needle - Strict equal comparison compatible.\r\n *\r\n * @returns {boolean} Whether or not the value could be located.\r\n */\nfunction inside (haystack, needle) {\n  let toValues = object => key => object[key];\n  let isArray = it => it instanceof Array;\n  let isObject = it => typeof it === 'object';\n  let values = it => Object.keys(it).map(toValues(it));\n\n  let areInside = it => inside(it, needle);\n\n  let insideArray = () => haystack.some(areInside);\n  let insideObject = () => values(haystack).some(areInside);\n\n  let array = () => isArray(haystack) && insideArray(haystack, needle);\n  let object = () => isObject(haystack) && insideObject(haystack, needle);\n  let matches = () => haystack === needle;\n  let search = () => array() || object();\n\n  return matches() || search()\n}\n\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nconst TEXT_NODE = 3;\n\nlet element = it => it.nodeType === ELEMENT_NODE;\nlet fragment = it => it.nodeType === DOCUMENT_FRAGMENT_NODE;\nlet text = it => it.nodeType === TEXT_NODE;\n\nvar is = prepare({\n  element,\n  equal,\n  existent: exists,\n  fragment,\n  inside,\n  text\n});\n\nmodule.exports = is;\n"]}