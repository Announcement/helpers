{"version":3,"sources":["helpers.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","pair","object","Object","keys","map","key","value","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","similar","reference","constructorsMatch","_typeof","equals","identical","every","item","has","exists","single","list","attempt","mutation","subject","parameters","alternative","inject","copy","find","negated","prepare","not","tmp","inside","haystack","needle","toValues","isObject","areInside","insideArray","insideObject","decompose","initial","composer","previous","current","reducer","where","select","compliant","normalize","pull","response","forEach","param","merge","ensure","listed","filter","append","query","search","_where","findIndex","push","_len2","_key2","beforeReduce","defineProperty","exports","property","hasOwnProperty","element","nodeType","document","ELEMENT_NODE","fragment","DOCUMENT_FRAGMENT_NODE","text","TEXT_NODE","is","equal","existent","is$1","freeze","default","as","decomposed","as$1","unique","normal","are"],"mappings":"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","file":"../dist/helpers.min.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{key: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\n\n/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray;\r\n  let toArray;\r\n  let fromArray;\r\n\r\n  isArray = (it) => it.constructor === Array;\r\n  toArray = (it) => isArray(it) ? it : [it];\r\n  fromArray = (a, b) => a.concat(b);\r\n\r\n  while (array.some(isArray)) {\r\n    array = array.map(toArray).reduce(fromArray);\r\n  }\r\n\r\n  return array\r\n}\n\n/**\r\n * Check if they're similar in origin (type & constructor)\r\n * @method isSimilar\r\n *\r\n * @param {object} reference\r\n * @param {object} object\r\n *\r\n * @return {boolean}\r\n */\r\nfunction similar (reference, object) {\r\n  let typesMatch;\r\n  let constructorsMatch;\r\n\r\n  constructorsMatch = reference.constructor === object.constructor;\r\n  typesMatch = typeof reference === typeof object;\r\n\r\n  return typesMatch && constructorsMatch\r\n}\n\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals (reference, object) {\r\n  return similar(reference, object) && identical(reference, object)\r\n}\r\n\r\n/**\r\n * Checks to see if two items of the same type and class are the same\r\n * @param identical\r\n *\r\n * @param {object} reference - what is being compared to\r\n * @param {object} object - what is being compared\r\n *\r\n * @return {boolean}\r\n */\r\nfunction identical (reference, object) {\r\n  let every = item =>\r\n    has(reference)(item.key) &&\r\n    has(object)(item.key) &&\r\n    equals(reference[item.key], object[item.key]);\r\n\r\n  // avoid unnecissary recursion\r\n  if (reference.constructor !== Object) {\r\n    return reference === object\r\n  }\r\n\r\n  return flatten([pair(reference), pair(object)]).every(every)\r\n}\n\n/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction exists (it) {\r\n  return it !== undefined && it !== null\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {};\r\n\r\n  function cycle (key, value) {\r\n    let duplicate = () => value === copy && false;\r\n    let effort = () => value === 'function' && attempt(transform, value);\r\n    let needle = () => value === 'object' && inject(value, transform);\r\n\r\n    return [duplicate, effort, needle].find(it => it())() || value\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]); }\r\n\r\n  return copy\r\n}\n\n/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\n\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp;\r\n\r\n  not = inject(it, negated);\r\n  not = inject(not, curry);\r\n  tmp = inject(it, curry);\r\n\r\n  tmp.not = not;\r\n\r\n  return tmp\r\n}\n\n/**\r\n * Detects if the needle is in the haystack.\r\n * @function inside\r\n *\r\n * @param {Object|Array} haystack - what we are looking in\r\n * @param {Object} needle - strict equal comparison compatible\r\n *\r\n * @return {Boolean} Whether or not the value could be located\r\n */\r\nfunction inside (haystack, needle) {\r\n  let toValues = object => key => object[key];\r\n  let isArray = it => it instanceof Array;\r\n  let isObject = it => typeof it === 'object';\r\n  let values = it => Object.keys(it).map(toValues(it));\r\n\r\n  let areInside = it => inside(it, needle);\r\n\r\n  let insideArray = () => haystack.some(areInside);\r\n  let insideObject = () => values(haystack).some(areInside);\r\n\r\n  let array = () => isArray(haystack) && insideArray(haystack, needle);\r\n  let object = () => isObject(haystack) && insideObject(haystack, needle);\r\n  let matches = () => haystack === needle;\r\n  let search = () => array() || object();\r\n\r\n  return matches() || search()\r\n}\n\nlet element = it =>\r\n  it.nodeType === document.ELEMENT_NODE;\r\n\r\nlet fragment = it =>\r\n  it.nodeType === document.DOCUMENT_FRAGMENT_NODE;\r\n\r\nlet text = it =>\r\n  it.nodeType === document.TEXT_NODE;\r\n\r\nlet is = prepare({\r\n  element,\r\n  fragment,\r\n  text,\r\n  inside,\r\n  equal: equals,\r\n  existent: exists\r\n});\r\n\r\n\r\n\n\nvar is$1 = Object.freeze({\n\tdefault: is,\n\telement: element,\n\tfragment: fragment,\n\ttext: text,\n\tequal: equals,\n\texistent: exists\n});\n\n/**\r\n * Applies functions to a value and moves down the chain if possible\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array$\r\n *\r\n * @param {Array} array - list of functions to be applied\r\n * @param {Object} initial - optional initial item\r\n *\r\n * @return Object\r\n */\r\nfunction decompose (array, initial) {\r\n  let composer = (previous, current) => attempt(current, previous);\r\n  let reducer = (it) => array.reduce(composer, initial || it);\r\n\r\n  return initial ? reducer(initial) : reducer\r\n}\n\nlet as = {\r\n  array,\r\n  pair,\r\n  method: curry,\r\n  flatten,\r\n  decomposed: decompose,\r\n  attempt\r\n};\r\n\r\n\r\n\n\nvar as$1 = Object.freeze({\n\tdefault: as,\n\tarray: array,\n\tpair: pair,\n\tmethod: curry,\n\tflatten: flatten,\n\tdecomposed: decompose,\n\tattempt: attempt\n});\n\n/**\r\n * useful inside of a pipeline\r\n * @method where\r\n * @version 3.0.0\r\n *\r\n * @param {Object.<string, string>} search - object with properties to match\r\n *\r\n * @return {boolean}\r\n */\r\nfunction where (reference, object) {\r\n  var keys;\r\n  var result;\r\n\r\n  let every = key => reference[key] === object[key];\r\n\r\n  keys = Object.keys(reference);\r\n  result = keys.every(every);\r\n\r\n  return result\r\n}\r\n\r\nvar _where = curry(where);\n\nlet isArray = it => it instanceof Array;\r\n\r\n/**\r\n * intended to be used with Array.prototype.reduce\r\n * @method select\r\n * @version 2.0.0\r\n *\r\n * @param {...string} property - property to pull from each object\r\n *\r\n * @return {function}\r\n */\r\nfunction select (...params) {\r\n  function compliant (it, key) {\r\n    return params.indexOf(key) !== -1 ? it[key] : [it[key]]\r\n  }\r\n\r\n  function prepare (it) {\r\n    for (var key in it) {\r\n      it[key] = compliant(it, key);\r\n    }\r\n\r\n    return it\r\n  }\r\n\r\n  function normalize (it) {\r\n    if (!isArray(it)) {\r\n      return [prepare(it)]\r\n    }\r\n\r\n    return it\r\n  }\r\n\r\n  function pull (item) {\r\n    var response;\r\n\r\n    let forEach = param => {\r\n      response[param] = item[param];\r\n    };\r\n\r\n    response = {};\r\n\r\n    params.forEach(forEach);\r\n\r\n    return response\r\n  }\r\n\r\n  function merge (reference, object) {\r\n    var keys;\r\n\r\n    let ensure = key => {\r\n      reference[key] = reference[key] || [];\r\n    };\r\n    let concat = key => {\r\n      reference[key] = reference[key].concat(object[key]);\r\n    };\r\n    let listed = key => params.indexOf(key) === -1;\r\n\r\n    keys = Object.keys(object).filter(listed);\r\n\r\n    keys.forEach(ensure);\r\n    keys.forEach(concat);\r\n\r\n    return reference\r\n  }\r\n\r\n  function append (array, item) {\r\n    var index;\r\n    var query;\r\n    var search;\r\n\r\n    query = pull(item);\r\n    search = _where(query);\r\n    index = array.findIndex(search);\r\n\r\n    if (index !== -1) {\r\n      array[index] = merge(array[index], item);\r\n    } else {\r\n      array.push(item);\r\n    }\r\n\r\n    return array\r\n  }\r\n\r\n  function reducer (previous, current) {\r\n    var array;\r\n    var item;\r\n\r\n    array = normalize(previous);\r\n    item = prepare(current);\r\n\r\n    array = append(array, item);\r\n\r\n    return array\r\n  }\r\n\r\n  return reducer\r\n}\n\nfunction beforeReduce (it) {\r\n  return it instanceof Array ? it : [it]\r\n}\r\n\r\n// normal is the most convenient implementation\r\n// filter is the most efficient implementation\r\n// reduce is the most reliable implementation\r\n\r\nlet unique = {\r\n  normal: curry(function normal (array, value) {\r\n    return array.filter(_where(value)).length > 1\r\n  }),\r\n\r\n  filter: function filter (value, index, array) {\r\n    return array.indexOf(value, index + 1) === -1\r\n  },\r\n\r\n  reduce: function reduce (previous, current) {\r\n    previous = beforeReduce(previous);\r\n\r\n    if (!previous.find(_where(current))) {\r\n      previous.push(current);\r\n    }\r\n\r\n    return previous\r\n  }\r\n};\n\n\n\nvar query = Object.freeze({\n\twhere: _where,\n\tselect: select,\n\tunique: unique\n});\n\n/** module helpers */\r\n// let helpers = {is, as}\r\nconst are = is$1;\r\n\r\n  // clone,\r\n  // combine,\r\n  // has,\r\n  // inject,\r\n  // negated,\r\n  // prepare\n\nexports.is = is$1;\nexports.are = are;\nexports.as = as$1;\nexports.query = query;\n"]}