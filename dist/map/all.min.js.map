{"version":3,"sources":["all.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","$toProperty","property","object","add","x","y","allAre","toLength","toProperty","toTotal","_len2","methods","_key2","map","reduce","from","module","exports"],"mappings":"AAAA,aAaA,SAASA,QAASC,EAAOC,GACvB,IAAIC,OAAAA,EAIJ,IAFAF,EAAQA,EAAMG,YAEiC,KAAvCD,EAAQF,EAAMI,aAAQC,KAAsBJ,EAAOK,OAAS,GAClEN,EAAME,GAASD,EAAOM,QAGxB,OAAOP,EAAMG,OAAOF,GAWtB,SAASD,MAAOQ,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,MAAOL,GACd,YAAcH,IAAPG,GAA2B,OAAPA,EAY7B,SAASM,MAAOC,GAkBd,SAASC,EAAWC,GAkBlB,SAASC,IAAoB,IAAA,IAAAC,EAAAC,UAAAd,OAAPe,EAAOZ,MAAAU,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAPD,EAAOC,GAAAF,UAAAE,GAO3B,OAJAC,EAASxB,QAAQkB,EAAQjB,MAAMoB,YAC/BI,EAAUC,EAAOC,MACNC,EAAMJ,GAtBnB,IAAIA,EACAC,EAEAI,EAAU,WAAA,OAAMb,EAAOc,MAAML,EAASD,IACtCE,EAAS,SAAAjB,GAAA,OAAMgB,GAAWhB,GAC1BmB,EAAQ,SAAAnB,GAAA,OAAOsB,EAAMtB,GAAsBoB,IAAhBZ,EAAUR,IAEzC,OAAOU,EAzBT,IAAIa,EAAS,SAAAV,GAAA,OAASA,EAAMf,OAASS,EAAOT,QACxC0B,EAAU,SAAAX,GAAA,OAASA,EAAMY,KAAKpB,QAC9BiB,EAAQ,SAAAtB,GAAA,OAAMuB,EAAOvB,KAAQwB,EAAQxB,IAEzC,OAAOO,EAAOT,QAAU,EAAIS,EAASC,MA2CvC,SAASkB,YAAaC,EAAUC,GAC9B,OAAOA,EAAOD,GAGhB,SAASE,IAATC,EAAAC,GACE,OAAOD,EAAIC,EAKb,SAASC,SAAoB,IAAA,IACvBlC,EAEAmC,EAAWC,WAAW,UACtBC,EAAUN,IAJaO,EAAAxB,UAAAd,OAATuC,EAASpC,MAAAmC,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAATD,EAASC,GAAA1B,UAAA0B,GA8B3B,OAxBAxC,EAASuC,EACNE,IAAIN,GACJO,OAAOL,GAEV,SAAkB1B,GAChB,IAAIO,EAEAC,EAAS,SAAAjB,GAAA,OAAMgB,GAAWhB,GAC1BuB,EAAS,WAAA,OAAMd,EAAOX,OAASA,GAGnC,OAAO,WAML,OAHAkB,EAAUC,EAAOC,OACPK,UAAYkB,QAvB5B,IAAIP,WAAa5B,MAAMoB,aAmCvBgB,OAAOC,QAAUX","file":"../dist/all.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\nfunction $toProperty (property, object) {\r\n  return object[property]\r\n}\r\n\r\nfunction add (x, y) {\r\n  return x + y\r\n}\r\n\r\nlet toProperty = curry($toProperty);\r\n\r\nfunction allAre (...methods) {\r\n  var length;\r\n\r\n  let toLength = toProperty('length');\r\n  let toTotal = add;\r\n\r\n  length = methods\r\n    .map(toLength)\r\n    .reduce(toTotal);\r\n\r\n  function prepare (params) {\r\n    var context;\r\n\r\n    let update = it => context || it;\r\n    let enough = () => params.length < length;\r\n    let from = () => fromPartial() || fromProxy();\r\n\r\n    return function (...args) {\r\n      var result;\r\n\r\n      context = update(this);\r\n      result = !enough() || from();\r\n\r\n      return result\r\n    }\r\n  }\r\n\r\n  function fromPartial () {}\r\n  function fromProxy () {}\r\n\r\n  return prepare([])\r\n}\n\nmodule.exports = allAre;\n"]}