{"version":3,"sources":["Compare.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","enough","input","missing","some","ready","transform","params","inputs","context","results","apply","update","fetch","callback","response","arguments","has","object","property","hasOwnProperty","pair","Object","keys","map","key","value","flatten","array$$1","isArray","toArray","fromArray","constructor","a","b","reduce","similar","reference","typesMatch","constructorsMatch","equals","identical","every","item","exists","Compare","polarity","isElement","isFragment","isText","isEqual","isExistant","Element","DocumentFragment","Text","module","exports"],"mappings":"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","file":"../Compare.js","sourcesContent":["'use strict';\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine(array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array(it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty(it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry(method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform(params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => (!ready(it) ? transform(it) : results());\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback(...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{key: string, value}>}\r\n */\r\nfunction pair(object) {\r\n  return Object.keys(object).map(key => {\r\n    return { key: key, value: object[key] }\r\n  })\r\n}\n\n/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten() {\r\n  let array$$1 = array(arguments);\r\n  let isArray;\r\n  let toArray;\r\n  let fromArray;\r\n\r\n  isArray = it => it.constructor === Array;\r\n  toArray = it => (isArray(it) ? it : [it]);\r\n  fromArray = (a, b) => a.concat(b);\r\n\r\n  while (array$$1.some(isArray)) {\r\n    array$$1 = array$$1.map(toArray).reduce(fromArray);\r\n  }\r\n\r\n  return array$$1\r\n}\n\n/**\r\n * Check if they're similar in origin (type & constructor)\r\n * @method isSimilar\r\n *\r\n * @param {object} reference\r\n * @param {object} object\r\n *\r\n * @return {boolean}\r\n */\r\nfunction similar(reference, object) {\r\n  let typesMatch;\r\n  let constructorsMatch;\r\n\r\n  constructorsMatch = reference.constructor === object.constructor;\r\n  typesMatch = typeof reference === typeof object;\r\n\r\n  return typesMatch && constructorsMatch\r\n}\n\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals(reference, object) {\r\n  return similar(reference, object) && identical(reference, object)\r\n}\r\n\r\n/**\r\n * Checks to see if two items of the same type and class are the same\r\n * @param identical\r\n *\r\n * @param {object} reference - what is being compared to\r\n * @param {object} object - what is being compared\r\n *\r\n * @return {boolean}\r\n */\r\nfunction identical(reference, object) {\r\n  let every = item =>\r\n    has(reference)(item.key) &&\r\n    has(object)(item.key) &&\r\n    equals(reference[item.key], object[item.key]);\r\n\r\n  // avoid unnecissary recursion\r\n  if (reference.constructor !== Object) {\r\n    return reference === object\r\n  }\r\n\r\n  return flatten([pair(reference), pair(object)]).every(every)\r\n}\n\n/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction exists(it) {\r\n  return it !== undefined && it !== null\r\n}\n\nclass Compare {\r\n  constructor(reference, polarity = true) {\r\n    this.reference = reference;\r\n    this.polarity = polarity;\r\n  }\r\n\r\n  get not() {\r\n    return new Compare(this.reference, !this.polarity)\r\n  }\r\n\r\n  static isElement(object) {\r\n    return object instanceof Element\r\n  }\r\n\r\n  static isFragment(object) {\r\n    return object.constructor === DocumentFragment\r\n  }\r\n\r\n  static isText(object) {\r\n    return object.constructor === Text\r\n  }\r\n\r\n  static isEqual(reference, object) {\r\n    return equals(reference, object)\r\n  }\r\n\r\n  static isExistant(object) {\r\n    return exists(object)\r\n  }\r\n\r\n  element() {\r\n    return Compare.isElement(this.reference)\r\n  }\r\n\r\n  fragment() {\r\n    return Compare.isFragment(this.reference)\r\n  }\r\n\r\n  text() {\r\n    return Compare.isText(this.reference)\r\n  }\r\n\r\n  equal(it) {\r\n    return Compare.isEqual(this.reference, it)\r\n  }\r\n\r\n  existant() {\r\n    return Compare.isExistant(this.reference)\r\n  }\r\n}\n\nmodule.exports = Compare;\n"]}