{"version":3,"sources":["as.js"],"names":["Object","defineProperty","exports","value","array","it","Array","prototype","slice","call","array$1","freeze","default","pair","object","keys","map","key","pair$1","combine","values","index","concat","indexOf","undefined","length","shift","empty","curry","method","enough","input","missing","some","ready","transform","parameters","inputs","context","results","apply","update","fetch","callback","response","arguments","curry$1","flatten","array$$1","isArray","toArray","fromArray","constructor","a","b","reduce","flatten$1","single","list","result","alone","exists","attempt","mutation","subject","valid","attempt$1","decompose","initial","composer","previous","current","reducer","decompose$1","decomposed"],"mappings":"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","file":"../as.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n\nvar array$1 = Object.freeze({\n\tdefault: array\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays.\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - Collection to be paired.\r\n *\r\n * @returns {Array.<{key: string, value}>} An array of the original object key-value pairs.\r\n */\nfunction pair (object) {\n  return Object\n    .keys(object)\n    .map(map)\n\n  function map (key) {\n    let value = object[key];\n\n    return {\n      key,\n      value\n    }\n  }\n}\n\n\n\n\nvar pair$1 = Object.freeze({\n\tdefault: pair\n});\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end.\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - List of existing items.\r\n * @param {Array} values - Proposed additions to the list.\r\n *\r\n * @returns {Array} - Collective array.\r\n */\nvar combine = function (array, values) {\n  let index;\n\n  array = array.concat([]);\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift();\n  }\n\n  return array.concat(values)\n};\n\n/**\r\n * Check to see if an item is null or undefined.\r\n *\r\n * @function empty\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} False, unless it is null or undefiend.\r\n */\nvar empty = function (it) {\n  return it === undefined || it === null\n};\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nvar curry = function (method) {\n  let enough = input => input.length >= method.length;\n  let missing = input => input.some(empty);\n  let ready = it => enough(it) && !missing(it);\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs;\n    var context;\n\n    let results = () => method.apply(context, inputs);\n    let update = it => context || it;\n    let fetch = it => !ready(it) ? transform(it) : results();\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response;\n\n      inputs = combine(parameters, array(arguments));\n      context = update(this);\n      response = fetch(inputs);\n\n      return response\n    }\n  }\n};\n\n\nvar curry$1 = Object.freeze({\n\tdefault: curry\n});\n\n/**\r\n * Recursively brings all arguments of arrays to the highest level.\r\n *\r\n * @function flatten\r\n *\r\n * @returns {Array} - Flattened array from the given arguments.\r\n */\nfunction flatten () {\n  let array$$1 = array(arguments);\n  let isArray;\n  let toArray;\n  let fromArray;\n\n  isArray = it => it.constructor === Array;\n  toArray = it => isArray(it) ? it : [ it ];\n  fromArray = (a, b) => a.concat(b);\n\n  while (array$$1.some(isArray)) {\n    array$$1 = array$$1.map(toArray).reduce(fromArray);\n  }\n\n  return array$$1\n}\n\n\n\n\nvar flatten$1 = Object.freeze({\n\tdefault: flatten\n});\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\n\nvar attempt$1 = Object.freeze({\n\tdefault: attempt\n});\n\n/**\r\n * Applies functions to a value and moves down the chain if possible.\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array\r\n *\r\n * @param {Array} array - List of functions to be applied.\r\n * @param {Object} initial - Optional initial item.\r\n *\r\n * @returns {Object} Mutated version of the initial value.\r\n */\nvar decompose = function (array, initial) {\n  let composer = (previous, current) => attempt(current, previous);\n  let reducer = it => array.reduce(composer, initial || it);\n\n  return initial ? reducer(initial) : reducer\n};\n\n\nvar decompose$1 = Object.freeze({\n\tdefault: decompose\n});\n\nexports.array = array$1;\nexports.attempt = attempt$1;\nexports.decomposed = decompose$1;\nexports.flatten = flatten$1;\nexports.method = curry$1;\nexports.pair = pair$1;\n"]}