{"version":3,"sources":["equals.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","pair","object","Object","keys","map","key","value","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","similar","reference","constructorsMatch","_typeof","equals","identical","every","item","has","property","hasOwnProperty","module","exports"],"mappings":"AAAA,aAaA,SAASA,QAASC,EAAOC,GACvB,IAAIC,OAAAA,EAIJ,IAFAF,EAAQA,EAAMG,YAEiC,KAAvCD,EAAQF,EAAMI,aAAQC,KAAsBJ,EAAOK,OAAS,GAClEN,EAAME,GAASD,EAAOM,QAGxB,OAAOP,EAAMG,OAAOF,GAWtB,SAASD,MAAOQ,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,MAAOL,GACd,YAAcH,IAAPG,GAA2B,OAAPA,EAY7B,SAASM,MAAOC,GAkBd,SAASC,EAAWC,GAkBlB,SAASC,IAAoB,IAAA,IAAAC,EAAAC,UAAAd,OAAPe,EAAOZ,MAAAU,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAPD,EAAOC,GAAAF,UAAAE,GAO3B,OAJAC,EAASxB,QAAQkB,EAAQjB,MAAMoB,YAC/BI,EAAUC,EAAOC,MACNC,EAAMJ,GAtBnB,IAAIA,EACAC,EAEAI,EAAU,WAAA,OAAMb,EAAOc,MAAML,EAASD,IACtCE,EAAS,SAAAjB,GAAA,OAAMgB,GAAWhB,GAC1BmB,EAAQ,SAAAnB,GAAA,OAAOsB,EAAMtB,GAAsBoB,IAAhBZ,EAAUR,IAEzC,OAAOU,EAzBT,IAAIa,EAAS,SAAAV,GAAA,OAASA,EAAMf,OAASS,EAAOT,QACxC0B,EAAU,SAAAX,GAAA,OAASA,EAAMY,KAAKpB,QAC9BiB,EAAQ,SAAAtB,GAAA,OAAMuB,EAAOvB,KAAQwB,EAAQxB,IAEzC,OAAOO,EAAOT,QAAU,EAAIS,EAASC,MAmEvC,SAASkB,KAAMC,GACb,OAAOC,OAAOC,KAAKF,GAAQG,IAAI,SAACC,GAC9B,OAAQA,IAAKA,EAAKC,MAAOL,EAAOI,MAapC,SAASE,QAASzC,GAChB,IAAI0C,OAAAA,EACAC,OAAAA,EACAC,OAAAA,EAMJ,IAJAF,EAAU,SAAClC,GAAD,OAAQA,EAAGqC,cAAgBpC,OACrCkC,EAAU,SAACnC,GAAD,OAAQkC,EAAQlC,GAAMA,GAAMA,IACtCoC,EAAY,SAAAE,EAAAC,GAAA,OAAUD,EAAE3C,OAAO4C,IAExB/C,EAAMiC,KAAKS,IAChB1C,EAAQA,EAAMsC,IAAIK,GAASK,OAAOJ,GAGpC,OAAO5C,EAYT,SAASiD,QAASC,EAAWf,GAC3B,IACIgB,OAAAA,EAKJ,OAHAA,EAAoBD,EAAUL,cAAgBV,EAAOU,kBACxC,IAAOK,EAAP,YAAAE,QAAOF,YAAP,IAA4Bf,EAA5B,YAAAiB,QAA4BjB,KAEpBgB,EAgBvB,SAASE,OAAQH,EAAWf,GAC1B,OAAOc,QAAQC,EAAWf,IAAWmB,UAAUJ,EAAWf,GAY5D,SAASmB,UAAWJ,EAAWf,GAC7B,IAAIoB,EAAQ,SAAAC,GAAA,OACVC,IAAIP,GAAWM,EAAKjB,MACpBkB,IAAItB,GAAQqB,EAAKjB,MACjBc,OAAOH,EAAUM,EAAKjB,KAAMJ,EAAOqB,EAAKjB,OAG1C,OAAIW,EAAUL,cAAgBT,OACrBc,IAAcf,EAGhBM,SAASP,KAAKgB,GAAYhB,KAAKC,KAAUoB,MAAMA,yNApGpDE,IAAM3C,MAAM,SAACqB,EAAQuB,GACvB,OAAOvB,EAAOwB,eAAeD,KAsG/BE,OAAOC,QAAUR","file":"../dist/equals.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{key: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\n\n/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray;\r\n  let toArray;\r\n  let fromArray;\r\n\r\n  isArray = (it) => it.constructor === Array;\r\n  toArray = (it) => isArray(it) ? it : [it];\r\n  fromArray = (a, b) => a.concat(b);\r\n\r\n  while (array.some(isArray)) {\r\n    array = array.map(toArray).reduce(fromArray);\r\n  }\r\n\r\n  return array\r\n}\n\n/**\r\n * Check if they're similar in origin (type & constructor)\r\n * @method isSimilar\r\n *\r\n * @param {object} reference\r\n * @param {object} object\r\n *\r\n * @return {boolean}\r\n */\r\nfunction similar (reference, object) {\r\n  let typesMatch;\r\n  let constructorsMatch;\r\n\r\n  constructorsMatch = reference.constructor === object.constructor;\r\n  typesMatch = typeof reference === typeof object;\r\n\r\n  return typesMatch && constructorsMatch\r\n}\n\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals (reference, object) {\r\n  return similar(reference, object) && identical(reference, object)\r\n}\r\n\r\n/**\r\n * Checks to see if two items of the same type and class are the same\r\n * @param identical\r\n *\r\n * @param {object} reference - what is being compared to\r\n * @param {object} object - what is being compared\r\n *\r\n * @return {boolean}\r\n */\r\nfunction identical (reference, object) {\r\n  let every = item =>\r\n    has(reference)(item.key) &&\r\n    has(object)(item.key) &&\r\n    equals(reference[item.key], object[item.key]);\r\n\r\n  // avoid unnecissary recursion\r\n  if (reference.constructor !== Object) {\r\n    return reference === object\r\n  }\r\n\r\n  return flatten([pair(reference), pair(object)]).every(every)\r\n}\n\nmodule.exports = equals;\n"]}