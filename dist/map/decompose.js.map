{"version":3,"sources":["decompose.js"],"names":["array","it","Array","prototype","slice","call","single","list","result","isArray","alone","length","shift","exists","undefined","attempt","mutation","subject","parameters","apply","method","valid","arguments","decompose","initial","composer","previous","current","reducer","reduce","module","exports"],"mappings":"AAAA;;AAEA;;;;;;;;;;AASA,IAAIA,QAAQ,UAAUC,EAAV,EAAc;AACxB,SAAOC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BJ,EAA3B,EAA+B,CAA/B,CAAP;AACD,CAFD;;AAIA;;;;;;;;;AASA,SAASK,MAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAIC,MAAJ;;AAEA,MAAIC,UAAWR,EAAD,IAAQ,OAAOA,EAAP,KAAc,QAAd,IAA0BA,cAAcC,KAA9D;AACA,MAAIQ,QAAQT,MAAMQ,QAAQR,EAAR,KAAeA,GAAGU,MAAH,KAAc,CAA/C;;AAEAH,WAASE,MAAMH,IAAN,IAAcA,KAAKK,KAAL,EAAd,GAA6BL,IAAtC;;AAEA,SAAOC,MAAP;AACD;;AAED;;;;;;;;;AASA,SAASK,MAAT,CAAiBZ,EAAjB,EAAqB;AACnB,SAAOA,OAAOa,SAAP,IAAoBb,OAAO,IAAlC;AACD;;AAED;;;;;;;;;;;;;;AAcA,IAAIc,UAAU,UAAUC,QAAV,EAAoBC,OAApB,EAA6B;AACzC,MAAIC,UAAJ;AACA,MAAIV,MAAJ;;AAEA,MAAIW,QAAQ,CAACC,MAAD,EAASF,UAAT,KAAwBE,OAAOD,KAAP,CAAa,IAAb,EAAmBD,UAAnB,CAApC;AACA,MAAIG,QAAQpB,MAAMY,OAAOZ,EAAP,KAAcK,OAAOL,EAAP,CAAhC;;AAEAiB,eAAalB,MAAMsB,SAAN,EAAiBlB,KAAjB,CAAuB,CAAvB,CAAb;AACAI,WAASW,MAAMH,QAAN,EAAgBE,UAAhB,CAAT;;AAEA,SAAOG,MAAMb,MAAN,KAAiBa,MAAMH,UAAN,CAAxB;AACD,CAXD;;AAaA;;;;;;;;;;;;;;AAcA,IAAIK,YAAY,UAAUvB,KAAV,EAAiBwB,OAAjB,EAA0B;AACxC,MAAIC,WAAW,CAACC,QAAD,EAAWC,OAAX,KAAuBZ,QAAQY,OAAR,EAAiBD,QAAjB,CAAtC;AACA,MAAIE,UAAU3B,MAAMD,MAAM6B,MAAN,CAAaJ,QAAb,EAAuBD,WAAWvB,EAAlC,CAApB;;AAEA,SAAOuB,UAAUI,QAAQJ,OAAR,CAAV,GAA6BI,OAApC;AACD,CALD;;AAOAE,OAAOC,OAAP,GAAiBR,SAAjB","file":"../decompose.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\n/**\r\n * Applies functions to a value and moves down the chain if possible.\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array\r\n *\r\n * @param {Array} array - List of functions to be applied.\r\n * @param {Object} initial - Optional initial item.\r\n *\r\n * @returns {Object} Mutated version of the initial value.\r\n */\nvar decompose = function (array, initial) {\n  let composer = (previous, current) => attempt(current, previous);\n  let reducer = it => array.reduce(composer, initial || it);\n\n  return initial ? reducer(initial) : reducer\n};\n\nmodule.exports = decompose;\n"]}