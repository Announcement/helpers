{"version":3,"sources":["unique.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","where","reference","object","keys","every","key","Object","beforeReduce","_where","unique","normal","value","filter","reduce","previous","current","find","push","module","exports"],"mappings":"AAAA,aAaA,SAASA,QAASC,EAAOC,GACvB,IAAIC,OAAAA,EAIJ,IAFAF,EAAQA,EAAMG,YAEiC,KAAvCD,EAAQF,EAAMI,aAAQC,KAAsBJ,EAAOK,OAAS,GAClEN,EAAME,GAASD,EAAOM,QAGxB,OAAOP,EAAMG,OAAOF,GAWtB,SAASD,MAAOQ,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,MAAOL,GACd,YAAcH,IAAPG,GAA2B,OAAPA,EAY7B,SAASM,MAAOC,GAkBd,SAASC,EAAWC,GAkBlB,SAASC,IAAoB,IAAA,IAAAC,EAAAC,UAAAd,OAAPe,EAAOZ,MAAAU,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAPD,EAAOC,GAAAF,UAAAE,GAO3B,OAJAC,EAASxB,QAAQkB,EAAQjB,MAAMoB,YAC/BI,EAAUC,EAAOC,MACNC,EAAMJ,GAtBnB,IAAIA,EACAC,EAEAI,EAAU,WAAA,OAAMb,EAAOc,MAAML,EAASD,IACtCE,EAAS,SAAAjB,GAAA,OAAMgB,GAAWhB,GAC1BmB,EAAQ,SAAAnB,GAAA,OAAOsB,EAAMtB,GAAsBoB,IAAhBZ,EAAUR,IAEzC,OAAOU,EAzBT,IAAIa,EAAS,SAAAV,GAAA,OAASA,EAAMf,OAASS,EAAOT,QACxC0B,EAAU,SAAAX,GAAA,OAASA,EAAMY,KAAKpB,QAC9BiB,EAAQ,SAAAtB,GAAA,OAAMuB,EAAOvB,KAAQwB,EAAQxB,IAEzC,OAAOO,EAAOT,QAAU,EAAIS,EAASC,MAoDvC,SAASkB,MAAOC,EAAWC,GACzB,IAAIC,EAGAC,EAAQ,SAAAC,GAAA,OAAOJ,EAAUI,KAASH,EAAOG,IAK7C,OAHAF,EAAOG,OAAOH,KAAKF,GACVE,EAAKC,MAAMA,GAOtB,SAASG,aAAcjC,GACrB,OAAOA,aAAcC,MAAQD,GAAMA,GAHrC,IAAIkC,OAAS5B,MAAMoB,OAUfS,QACFC,OAAQ9B,MAAM,SAAiBd,EAAO6C,GACpC,OAAO7C,EAAM8C,OAAOJ,OAAOG,IAAQvC,OAAS,IAG9CwC,OAAQ,SAAiBD,EAAO3C,EAAOF,GACrC,OAA4C,IAArCA,EAAMI,QAAQyC,EAAO3C,EAAQ,IAGtC6C,OAAQ,SAAiBC,EAAUC,GAOjC,OANAD,EAAWP,aAAaO,IAEVE,KAAKR,OAAOO,KACxBD,EAASG,KAAKF,GAGTD,IAIXI,OAAOC,QAAUV","file":"../dist/unique.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * useful inside of a pipeline\r\n * @method where\r\n * @version 3.0.0\r\n *\r\n * @param {Object.<string, string>} search - object with properties to match\r\n *\r\n * @return {boolean}\r\n */\r\nfunction where (reference, object) {\r\n  var keys;\r\n  var result;\r\n\r\n  let every = key => reference[key] === object[key];\r\n\r\n  keys = Object.keys(reference);\r\n  result = keys.every(every);\r\n\r\n  return result\r\n}\r\n\r\nvar _where = curry(where);\n\nfunction beforeReduce (it) {\r\n  return it instanceof Array ? it : [it]\r\n}\r\n\r\n// normal is the most convenient implementation\r\n// filter is the most efficient implementation\r\n// reduce is the most reliable implementation\r\n\r\nlet unique = {\r\n  normal: curry(function normal (array, value) {\r\n    return array.filter(_where(value)).length > 1\r\n  }),\r\n\r\n  filter: function filter (value, index, array) {\r\n    return array.indexOf(value, index + 1) === -1\r\n  },\r\n\r\n  reduce: function reduce (previous, current) {\r\n    previous = beforeReduce(previous);\r\n\r\n    if (!previous.find(_where(current))) {\r\n      previous.push(current);\r\n    }\r\n\r\n    return previous\r\n  }\r\n};\n\nmodule.exports = unique;\n"]}