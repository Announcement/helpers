{"version":3,"sources":["helpers.js"],"names":["similar","reference","object","typesMatch","constructorsMatch","constructor","equal","exists","it","undefined","array","Array","prototype","slice","call","array$1","Object","freeze","default","single","list","result","isArray","alone","length","shift","attempt","mutation","subject","parameters","apply","method","valid","arguments","attempt$1","inject","transform","copy","keys","isObject","name","isFunction","forObject","forFunction","forEach","key","value","combine","values","index","concat","indexOf","empty","curry","enough","input","missing","some","ready","inputs","context","results","update","fetch","callback","response","curry$1","negated","prepare","not","tmp","inside","haystack","needle","toValues","map","areInside","insideArray","insideObject","matches","search","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","element","nodeType","fragment","text","is","existent","$is","pair","pair$1","flatten","array$$1","toArray","fromArray","a","b","reduce","flatten$1","decompose","initial","composer","previous","current","reducer","decompose$1","$as","decomposed","_where","where","every","select","params","compliant","normalize","pull","item","param","merge","ensure","listed","filter","append","query","findIndex","push","unique","normal","beforeReduce","find","$query","exports","are","as"],"mappings":"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","file":"../helpers.js","sourcesContent":["'use strict';\n\n/**\r\n * Check if they're similar in origin (type & constructor).\r\n *\r\n * @function similar\r\n *\r\n * @param {Object} reference - For comparison reference.\r\n * @param {Object} object - To be compared.\r\n *\r\n * @returns {boolean} True if they have the same type and constructor.\r\n */\nfunction similar (reference, object) {\n  let typesMatch;\n  let constructorsMatch;\n\n  constructorsMatch = reference.constructor === object.constructor;\n  typesMatch = typeof reference === typeof object;\n\n  return typesMatch && constructorsMatch\n}\n\n// import has from './has' // hasOwnProperty\n// import pair from './pair' // {key: value} => [{key: key, value: value}]\n// import flatten from './flatten' // [[[[1]], 2]] => [1, 2]\nvar equal = function (reference, object) {\n  if (!similar(reference, object)) {\n    return false\n  }\n\n  // if (reference.constructor !== Object) {\n  //   return reference === object\n  // }\n\n  // return flatten([\n  //   pair(reference),\n  //   pair(object)\n  // ])\n  // .every(item => {\n  //   return has(reference)(item.key) &&\n  //     has(object)(item.key) &&\n  //     equals(reference[item.key], object[item.key])\n  // })\n};\n\n// function equals (r, o) {\n//   // Are they of the same type?\n//   if (typeof r !== typeof o || r.constructor !== o.constructor) {\n//     return false\n//   }\n//\n//   // Do we need to check recursively?\n//   if (r.constructor !== Object) {\n//     return r === o\n//   }\n//\n//   return flatten([\n//     pair(r),\n//     pair(o)\n//   ])\n//   .every(item => {\n//     return has(r)(item.key) &&\n//       has(o)(item.key) &&\n//       equals(r[item.key], o[item.key])\n//   })\n// }\n//\n// export default equals\n\n\n\n// export default function () {\n//   // this is done to prevent scope/global leakage\n//   return equals.apply(this, arguments)\n//\n//   /**\n//    * Compares reference object to another object.\n//    *\n//    * @function equals\n//    *\n//    * @see has\n//    * @see pair\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - That matches the reference.\n//    *\n//    * @returns {boolean} True, unless they are not equal.\n//    */\n//   function equals (reference, object) {\n//     return similar(reference, object) && identical(reference, object)\n//   }\n//\n//   /**\n//    * Checks to see if two items of the same type and class are the same.\n//    *\n//    * @function identical\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - A similar object to the reference.\n//    *\n//    * @returns {boolean} True, unless reference, object are different type or constructor.\n//    */\n//   function identical (reference, object) {\n//     return test() || pairs()\n//\n//     function test () {\n//       let isObject = () => reference.constructor === Object\n//       let isEqual = () => reference === object\n//\n//       return !isObject() && isEqual()\n//     }\n//\n//     function pairs () {\n//       let asPair = it => pair(it)\n//       let array = [reference, object].map(asPair)\n//\n//       return flatten(array).every(every)\n//     }\n//\n//     function every (item) {\n//       let both = it => has(reference)(it) && has(object)(it)\n//       let match = it => equals(reference[it], object[it])\n//\n//       return !both(item.key) || match(item.key)\n//     }\n//   }\n// }\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n\nvar array$1 = Object.freeze({\n\tdefault: array\n});\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\n\nvar attempt$1 = Object.freeze({\n\tdefault: attempt\n});\n\n/**\n * Injects a transformer into each element of a collection.\n *\n * @function inject\n *\n * @see attempt\n *\n * @param {Object.<string, Function>} it - Collection of functions.\n * @param {Function} transform - Mutator function to run through each of the functions in it.\n *\n * @returns {Object.<string, Function>} All it functions, but mutated via transform.\n */\nfunction inject (it, transform) {\n  var copy;\n  var keys;\n\n  let isObject = it =>\n    typeof it === 'object' && it.constructor.name === 'Object';\n\n  let isFunction = it =>\n    typeof it === 'function' && it.constructor.name === 'Function';\n\n  let forObject = it =>\n    isObject(it) && inject(it, transform);\n\n  let forFunction = it =>\n    isFunction(it) && attempt(transform, it);\n\n  keys = Object.keys(it);\n  copy = {};\n\n  keys.forEach(forEach);\n\n  return copy\n\n  function forEach (key) {\n    var value;\n\n    value = it[key];\n\n    value = attempt(forObject, value);\n    value = attempt(forFunction, value);\n\n    copy[key] = value;\n  }\n}\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end.\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - List of existing items.\r\n * @param {Array} values - Proposed additions to the list.\r\n *\r\n * @returns {Array} - Collective array.\r\n */\nvar combine = function (array, values) {\n  let index;\n\n  array = array.concat([]);\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift();\n  }\n\n  return array.concat(values)\n};\n\n/**\r\n * Check to see if an item is null or undefined.\r\n *\r\n * @function empty\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} False, unless it is null or undefiend.\r\n */\nvar empty = function (it) {\n  return it === undefined || it === null\n};\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nvar curry = function (method) {\n  let enough = input => input.length >= method.length;\n  let missing = input => input.some(empty);\n  let ready = it => enough(it) && !missing(it);\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs;\n    var context;\n\n    let results = () => method.apply(context, inputs);\n    let update = it => context || it;\n    let fetch = it => !ready(it) ? transform(it) : results();\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response;\n\n      inputs = combine(parameters, array(arguments));\n      context = update(this);\n      response = fetch(inputs);\n\n      return response\n    }\n  }\n};\n\n\nvar curry$1 = Object.freeze({\n\tdefault: curry\n});\n\n/**\r\n * Returns a modified version of a function with negated boolean output.\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - Method to be negated.\r\n *\r\n * @returns {Function} Function with inverse output.\r\n */\nfunction negated (it) {\n  return function () {\n    return !it.apply(this, arguments)\n  }\n}\n\nfunction prepare (it) {\n  var not;\n  var tmp;\n\n  not = inject(it, negated);\n  not = inject(not, curry);\n  tmp = inject(it, curry);\n\n  tmp.not = not;\n\n  return tmp\n}\n\n/**\r\n * Detects if the needle is in the haystack.\r\n *\r\n * @function inside\r\n *\r\n * @param {Object|Array} haystack - What we are looking in.\r\n * @param {Object} needle - Strict equal comparison compatible.\r\n *\r\n * @returns {boolean} Whether or not the value could be located.\r\n */\nfunction inside (haystack, needle) {\n  let toValues = object => key => object[key];\n  let isArray = it => it instanceof Array;\n  let isObject = it => typeof it === 'object';\n  let values = it => Object.keys(it).map(toValues(it));\n\n  let areInside = it => inside(it, needle);\n\n  let insideArray = () => haystack.some(areInside);\n  let insideObject = () => values(haystack).some(areInside);\n\n  let array = () => isArray(haystack) && insideArray(haystack, needle);\n  let object = () => isObject(haystack) && insideObject(haystack, needle);\n  let matches = () => haystack === needle;\n  let search = () => array() || object();\n\n  return matches() || search()\n}\n\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nconst TEXT_NODE = 3;\n\nlet element = it => it.nodeType === ELEMENT_NODE;\nlet fragment = it => it.nodeType === DOCUMENT_FRAGMENT_NODE;\nlet text = it => it.nodeType === TEXT_NODE;\n\nvar is = prepare({\n  element,\n  equal,\n  existent: exists,\n  fragment,\n  inside,\n  text\n});\n\n\nvar $is = Object.freeze({\n\tdefault: is\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays.\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - Collection to be paired.\r\n *\r\n * @returns {Array.<{key: string, value}>} An array of the original object key-value pairs.\r\n */\nfunction pair (object) {\n  return Object\n    .keys(object)\n    .map(map)\n\n  function map (key) {\n    let value = object[key];\n\n    return {\n      key,\n      value\n    }\n  }\n}\n\n\n\n\nvar pair$1 = Object.freeze({\n\tdefault: pair\n});\n\n/**\r\n * Recursively brings all arguments of arrays to the highest level.\r\n *\r\n * @function flatten\r\n *\r\n * @returns {Array} - Flattened array from the given arguments.\r\n */\nfunction flatten () {\n  let array$$1 = array(arguments);\n  let isArray;\n  let toArray;\n  let fromArray;\n\n  isArray = it => it.constructor === Array;\n  toArray = it => isArray(it) ? it : [ it ];\n  fromArray = (a, b) => a.concat(b);\n\n  while (array$$1.some(isArray)) {\n    array$$1 = array$$1.map(toArray).reduce(fromArray);\n  }\n\n  return array$$1\n}\n\n\n\n\nvar flatten$1 = Object.freeze({\n\tdefault: flatten\n});\n\n/**\r\n * Applies functions to a value and moves down the chain if possible.\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array\r\n *\r\n * @param {Array} array - List of functions to be applied.\r\n * @param {Object} initial - Optional initial item.\r\n *\r\n * @returns {Object} Mutated version of the initial value.\r\n */\nvar decompose = function (array, initial) {\n  let composer = (previous, current) => attempt(current, previous);\n  let reducer = it => array.reduce(composer, initial || it);\n\n  return initial ? reducer(initial) : reducer\n};\n\n\nvar decompose$1 = Object.freeze({\n\tdefault: decompose\n});\n\n\n\nvar $as = Object.freeze({\n\tarray: array$1,\n\tattempt: attempt$1,\n\tdecomposed: decompose$1,\n\tflatten: flatten$1,\n\tmethod: curry$1,\n\tpair: pair$1\n});\n\nvar _where;\n\n/**\r\n * Verifies entry matches. Useful inside of a (filter) pipeline.\r\n *\r\n * @function where\r\n * @version 3.0.0\r\n *\r\n * @param {Object.<string, string>} search - Object with entries to match.\r\n * @param {Object.<string, string>} object - Input item to be tested.\r\n *\r\n * @returns {boolean} True if given entries are the same.\r\n */\nfunction where (search, object) {\n  var keys;\n  var result;\n\n  let every = key => search[key] === object[key];\n\n  keys = Object.keys(search);\n  result = keys.every(every);\n\n  return result\n}\n\n_where = curry(where);\n\n/**\r\n * Intended to be used with Array.prototype.reduce.\r\n *\r\n * @function select\r\n * @version 3.0.0\r\n *\r\n * @param {...string} it - Property to pull from each object.\r\n *\r\n * @returns {Function} A callback function for reducing objects to similar objects with only specified properties.\r\n */\nfunction select (it) {\n  let params = flatten(it, array(arguments));\n  let isArray = it => it instanceof Array;\n\n  function compliant (it, key) {\n    return params.indexOf(key) !== -1 ? it[key] : [ it[key] ]\n  }\n\n  function prepare (it) {\n    var key;\n\n    for (key in it) {\n      it[key] = compliant(it, key);\n    }\n\n    return it\n  }\n\n  function normalize (it) {\n    if (!isArray(it)) {\n      return [ prepare(it) ]\n    }\n\n    return it\n  }\n\n  function pull (item) {\n    var response;\n\n    let forEach = param => {\n      response[param] = item[param];\n    };\n\n    response = {};\n\n    params.forEach(forEach);\n\n    return response\n  }\n\n  function merge (reference, object) {\n    var keys;\n\n    let ensure = key => {\n      reference[key] = reference[key] || [];\n    };\n    let concat = key => {\n      reference[key] = reference[key].concat(object[key]);\n    };\n    let listed = key => params.indexOf(key) === -1;\n\n    keys = Object.keys(object).filter(listed);\n\n    keys.forEach(ensure);\n    keys.forEach(concat);\n\n    return reference\n  }\n\n  function append (array$$1, item) {\n    var index;\n    var query;\n    var search;\n\n    query = pull(item);\n    search = _where(query);\n    index = array$$1.findIndex(search);\n\n    if (index !== -1) {\n      array$$1[index] = merge(array$$1[index], item);\n    } else {\n      array$$1.push(item);\n    }\n\n    return array$$1\n  }\n\n  function reducer (previous, current) {\n    var array$$1;\n    var item;\n\n    array$$1 = normalize(previous);\n    item = prepare(current);\n\n    array$$1 = append(array$$1, item);\n\n    return array$$1\n  }\n\n  return reducer\n}\n\n// normal is the most convenient implementation\n// filter is the most efficient implementation\n// reduce is the most reliable implementation\n\nvar unique = {\n  normal: curry(function normal (array, value) {\n    return array.filter(_where(value)).length > 1\n  }),\n  filter: function filter (value, index, array) {\n    return array.indexOf(value, index + 1) === -1\n  },\n  reduce: function reduce (previous, current) {\n    let beforeReduce = it => it instanceof Array ? it : [ it ];\n\n    previous = beforeReduce(previous);\n\n    if (!previous.find(_where(current))) {\n      previous.push(current);\n    }\n\n    return previous\n  }\n};\n\n\n\nvar $query = Object.freeze({\n\tselect: select,\n\tunique: unique,\n\tget where () { return _where; }\n});\n\nexports.are = $is;\nexports.as = $as;\nexports.is = $is;\nexports.query = $query;\n\n// clone,\n// combine,\n// has,\n// inject,\n// negated,\n// prepare\n"]}