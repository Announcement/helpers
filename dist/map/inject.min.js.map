{"version":3,"sources":["inject.js"],"names":["array","it","Array","prototype","slice","call","single","list","length","shift","attempt","mutation","subject","parameters","alternative","arguments","apply","this","inject","transform","copy","key","value","find","module","exports"],"mappings":"AAAA,aAUA,SAASA,MAAOC,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,OAAQC,GACf,IACIC,EAKJ,OAHAA,EAASD,EAAKC,OACM,IAAXA,EAAeD,EAAKE,QAAUF,EAiBzC,SAASG,QAASC,EAAUC,GAC1B,IAAIC,OAAAA,EACAC,OAAAA,EAQJ,OALAD,EAAab,MAAMe,WAAWX,MAAM,GACpCU,EAAcR,OAAOO,GAEVF,EAASK,MAAMC,KAAMJ,IAEbC,EAerB,SAASI,OAAQjB,EAAIkB,GACnB,IAAIC,KAUJ,IAAK,IAAIC,KAAOpB,EAAMmB,EAAKC,GAR3B,SAAgBA,EAAKC,GAKnB,OAJgB,WAAA,OAAMA,IAAUF,IAAQ,GAC3B,WAAA,MAAgB,aAAVE,GAAwBZ,QAAQS,EAAWG,IACjD,WAAA,MAAgB,WAAVA,GAAsBJ,OAAOI,EAAOH,KAEpBI,KAAK,SAAAtB,GAAA,OAAMA,SAAWqB,GAGnBD,EAAKpB,EAAGoB,IAEhD,OAAOD,EAGTI,OAAOC,QAAUP","file":"../dist/inject.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {};\r\n\r\n  function cycle (key, value) {\r\n    let duplicate = () => value === copy && false;\r\n    let effort = () => value === 'function' && attempt(transform, value);\r\n    let needle = () => value === 'object' && inject(value, transform);\r\n\r\n    return [duplicate, effort, needle].find(it => it())() || value\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]); }\r\n\r\n  return copy\r\n}\n\nmodule.exports = inject;\n"]}