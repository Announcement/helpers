{"version":3,"sources":["as.js"],"names":["array","it","Array","prototype","slice","call","pair","object","Object","keys","map","key","value","combine","values","index","concat","indexOf","undefined","length","shift","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","single","list","attempt","mutation","subject","parameters","alternative","decompose","initial","composer","previous","current","reducer","defineProperty","exports","as","decomposed"],"mappings":"AAAA,aAYA,SAASA,MAAOC,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAYxC,SAASK,KAAMC,GACb,OAAOC,OAAOC,KAAKF,GAAQG,IAAI,SAACC,GAC9B,OAAQA,IAAKA,EAAKC,MAAOL,EAAOI,MAepC,SAASE,QAASb,EAAOc,GACvB,IAAIC,OAAAA,EAIJ,IAFAf,EAAQA,EAAMgB,YAEiC,KAAvCD,EAAQf,EAAMiB,aAAQC,KAAsBJ,EAAOK,OAAS,GAClEnB,EAAMe,GAASD,EAAOM,QAGxB,OAAOpB,EAAMgB,OAAOF,GAWtB,SAASO,MAAOpB,GACd,YAAciB,IAAPjB,GAA2B,OAAPA,EAY7B,SAASqB,MAAOC,GAkBd,SAASC,EAAWC,GAkBlB,SAASC,IAAoB,IAAA,IAAAC,EAAAC,UAAAT,OAAPU,EAAO3B,MAAAyB,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAPD,EAAOC,GAAAF,UAAAE,GAO3B,OAJAC,EAASlB,QAAQY,EAAQzB,MAAM4B,YAC/BI,EAAUC,EAAOC,MACNC,EAAMJ,GAtBnB,IAAIA,EACAC,EAEAI,EAAU,WAAA,OAAMb,EAAOc,MAAML,EAASD,IACtCE,EAAS,SAAAhC,GAAA,OAAM+B,GAAW/B,GAC1BkC,EAAQ,SAAAlC,GAAA,OAAOqC,EAAMrC,GAAsBmC,IAAhBZ,EAAUvB,IAEzC,OAAOyB,EAzBT,IAAIa,EAAS,SAAAV,GAAA,OAASA,EAAMV,OAASI,EAAOJ,QACxCqB,EAAU,SAAAX,GAAA,OAASA,EAAMY,KAAKpB,QAC9BiB,EAAQ,SAAArC,GAAA,OAAMsC,EAAOtC,KAAQuC,EAAQvC,IAEzC,OAAOsB,EAAOJ,QAAU,EAAII,EAASC,MAoDvC,SAASkB,QAAS1C,GAChB,IAAI2C,OAAAA,EACAC,OAAAA,EACAC,OAAAA,EAMJ,IAJAF,EAAU,SAAC1C,GAAD,OAAQA,EAAG6C,cAAgB5C,OACrC0C,EAAU,SAAC3C,GAAD,OAAQ0C,EAAQ1C,GAAMA,GAAMA,IACtC4C,EAAY,SAAAE,EAAAC,GAAA,OAAUD,EAAE/B,OAAOgC,IAExBhD,EAAMyC,KAAKE,IAChB3C,EAAQA,EAAMU,IAAIkC,GAASK,OAAOJ,GAGpC,OAAO7C,EAWT,SAASkD,OAAQC,GACf,IACIhC,EAKJ,OAHAA,EAASgC,EAAKhC,OACM,IAAXA,EAAegC,EAAK/B,QAAU+B,EAiBzC,SAASC,QAASC,EAAUC,GAC1B,IAAIC,OAAAA,EACAC,OAAAA,EAQJ,OALAD,EAAavD,MAAM4B,WAAWxB,MAAM,GACpCoD,EAAcN,OAAOK,GAEVF,EAAShB,MAAMH,KAAMqB,IAEbC,EAiBrB,SAASC,UAAWzD,EAAO0D,GACzB,IAAIC,EAAW,SAACC,EAAUC,GAAX,OAAuBT,QAAQS,EAASD,IACnDE,EAAU,SAAC7D,GAAD,OAAQD,EAAMiD,OAAOU,EAAUD,GAAWzD,IAExD,OAAOyD,EAAUI,EAAQJ,GAAWI,EA/MtCtD,OAAOuD,eAAeC,QAAS,cAAgBpD,OAAO,IAkNtD,IAAIqD,IACFjE,MAAAA,MACAM,KAAAA,KACAiB,OAAQD,MACRoB,QAAAA,QACAwB,WAAYT,UACZL,QAAAA,SAGFY,QAAA,QAAqBC,GACrBD,QAAQhE,MAAQA,MAChBgE,QAAQ1D,KAAOA,KACf0D,QAAQzC,OAASD,MACjB0C,QAAQtB,QAAUA,QAClBsB,QAAQE,WAAaT,UACrBO,QAAQZ,QAAUA","file":"../dist/as.min.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{key: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray;\r\n  let toArray;\r\n  let fromArray;\r\n\r\n  isArray = (it) => it.constructor === Array;\r\n  toArray = (it) => isArray(it) ? it : [it];\r\n  fromArray = (a, b) => a.concat(b);\r\n\r\n  while (array.some(isArray)) {\r\n    array = array.map(toArray).reduce(fromArray);\r\n  }\r\n\r\n  return array\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Applies functions to a value and moves down the chain if possible\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array$\r\n *\r\n * @param {Array} array - list of functions to be applied\r\n * @param {Object} initial - optional initial item\r\n *\r\n * @return Object\r\n */\r\nfunction decompose (array, initial) {\r\n  let composer = (previous, current) => attempt(current, previous);\r\n  let reducer = (it) => array.reduce(composer, initial || it);\r\n\r\n  return initial ? reducer(initial) : reducer\r\n}\n\nlet as = {\r\n  array,\r\n  pair,\r\n  method: curry,\r\n  flatten,\r\n  decomposed: decompose,\r\n  attempt\r\n};\n\nexports['default'] = as;\nexports.array = array;\nexports.pair = pair;\nexports.method = curry;\nexports.flatten = flatten;\nexports.decomposed = decompose;\nexports.attempt = attempt;\n"]}