{"version":3,"sources":["query.js"],"names":["Object","defineProperty","exports","value","combine","array","values","index","concat","indexOf","undefined","length","shift","$array","it","Array","prototype","slice","call","empty","curry","method","enough","input","missing","some","ready","transform","parameters","inputs","context","results","apply","update","fetch","callback","response","arguments","where","search","object","keys","result","every","key","flatten","isArray","toArray","fromArray","constructor","a","b","map","reduce","select","params","compliant","prepare","normalize","pull","item","forEach","param","merge","reference","ensure","listed","filter","append","query","findIndex","push","reducer","previous","current","unique","normal","beforeReduce","find"],"mappings":"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","file":"../query.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end.\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - List of existing items.\r\n * @param {Array} values - Proposed additions to the list.\r\n *\r\n * @returns {Array} - Collective array.\r\n */\nvar combine = function (array, values) {\n  let index;\n\n  array = array.concat([]);\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift();\n  }\n\n  return array.concat(values)\n};\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar $array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n/**\r\n * Check to see if an item is null or undefined.\r\n *\r\n * @function empty\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} False, unless it is null or undefiend.\r\n */\nvar empty = function (it) {\n  return it === undefined || it === null\n};\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nvar curry = function (method) {\n  let enough = input => input.length >= method.length;\n  let missing = input => input.some(empty);\n  let ready = it => enough(it) && !missing(it);\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs;\n    var context;\n\n    let results = () => method.apply(context, inputs);\n    let update = it => context || it;\n    let fetch = it => !ready(it) ? transform(it) : results();\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response;\n\n      inputs = combine(parameters, $array(arguments));\n      context = update(this);\n      response = fetch(inputs);\n\n      return response\n    }\n  }\n};\n\n/**\r\n * Verifies entry matches. Useful inside of a (filter) pipeline.\r\n *\r\n * @function where\r\n * @version 3.0.0\r\n *\r\n * @param {Object.<string, string>} search - Object with entries to match.\r\n * @param {Object.<string, string>} object - Input item to be tested.\r\n *\r\n * @returns {boolean} True if given entries are the same.\r\n */\nfunction where (search, object) {\n  var keys;\n  var result;\n\n  let every = key => search[key] === object[key];\n\n  keys = Object.keys(search);\n  result = keys.every(every);\n\n  return result\n}\n\nexports.where = curry(where);\n\n/**\r\n * Recursively brings all arguments of arrays to the highest level.\r\n *\r\n * @function flatten\r\n *\r\n * @returns {Array} - Flattened array from the given arguments.\r\n */\nfunction flatten () {\n  let array = $array(arguments);\n  let isArray;\n  let toArray;\n  let fromArray;\n\n  isArray = it => it.constructor === Array;\n  toArray = it => isArray(it) ? it : [ it ];\n  fromArray = (a, b) => a.concat(b);\n\n  while (array.some(isArray)) {\n    array = array.map(toArray).reduce(fromArray);\n  }\n\n  return array\n}\n\n/**\r\n * Intended to be used with Array.prototype.reduce.\r\n *\r\n * @function select\r\n * @version 3.0.0\r\n *\r\n * @param {...string} it - Property to pull from each object.\r\n *\r\n * @returns {Function} A callback function for reducing objects to similar objects with only specified properties.\r\n */\nfunction select (it) {\n  let params = flatten(it, $array(arguments));\n  let isArray = it => it instanceof Array;\n\n  function compliant (it, key) {\n    return params.indexOf(key) !== -1 ? it[key] : [ it[key] ]\n  }\n\n  function prepare (it) {\n    var key;\n\n    for (key in it) {\n      it[key] = compliant(it, key);\n    }\n\n    return it\n  }\n\n  function normalize (it) {\n    if (!isArray(it)) {\n      return [ prepare(it) ]\n    }\n\n    return it\n  }\n\n  function pull (item) {\n    var response;\n\n    let forEach = param => {\n      response[param] = item[param];\n    };\n\n    response = {};\n\n    params.forEach(forEach);\n\n    return response\n  }\n\n  function merge (reference, object) {\n    var keys;\n\n    let ensure = key => {\n      reference[key] = reference[key] || [];\n    };\n    let concat = key => {\n      reference[key] = reference[key].concat(object[key]);\n    };\n    let listed = key => params.indexOf(key) === -1;\n\n    keys = Object.keys(object).filter(listed);\n\n    keys.forEach(ensure);\n    keys.forEach(concat);\n\n    return reference\n  }\n\n  function append (array, item) {\n    var index;\n    var query;\n    var search;\n\n    query = pull(item);\n    search = exports.where(query);\n    index = array.findIndex(search);\n\n    if (index !== -1) {\n      array[index] = merge(array[index], item);\n    } else {\n      array.push(item);\n    }\n\n    return array\n  }\n\n  function reducer (previous, current) {\n    var array;\n    var item;\n\n    array = normalize(previous);\n    item = prepare(current);\n\n    array = append(array, item);\n\n    return array\n  }\n\n  return reducer\n}\n\n// normal is the most convenient implementation\n// filter is the most efficient implementation\n// reduce is the most reliable implementation\n\nvar unique = {\n  normal: curry(function normal (array, value) {\n    return array.filter(exports.where(value)).length > 1\n  }),\n  filter: function filter (value, index, array) {\n    return array.indexOf(value, index + 1) === -1\n  },\n  reduce: function reduce (previous, current) {\n    let beforeReduce = it => it instanceof Array ? it : [ it ];\n\n    previous = beforeReduce(previous);\n\n    if (!previous.find(exports.where(current))) {\n      previous.push(current);\n    }\n\n    return previous\n  }\n};\n\nexports.select = select;\nexports.unique = unique;\n"]}