{"version":3,"sources":["is.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","pair","object","Object","keys","map","key","value","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","similar","reference","constructorsMatch","_typeof","equals","identical","every","item","has","exists","single","list","attempt","mutation","subject","parameters","alternative","inject","copy","find","negated","prepare","not","tmp","inside","haystack","needle","toValues","isObject","areInside","insideArray","insideObject","defineProperty","exports","property","hasOwnProperty","element","nodeType","document","ELEMENT_NODE","fragment","DOCUMENT_FRAGMENT_NODE","text","TEXT_NODE","is","equal","existent"],"mappings":"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","file":"../dist/is.min.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n});\n\n/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{key: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\n\n/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray;\r\n  let toArray;\r\n  let fromArray;\r\n\r\n  isArray = (it) => it.constructor === Array;\r\n  toArray = (it) => isArray(it) ? it : [it];\r\n  fromArray = (a, b) => a.concat(b);\r\n\r\n  while (array.some(isArray)) {\r\n    array = array.map(toArray).reduce(fromArray);\r\n  }\r\n\r\n  return array\r\n}\n\n/**\r\n * Check if they're similar in origin (type & constructor)\r\n * @method isSimilar\r\n *\r\n * @param {object} reference\r\n * @param {object} object\r\n *\r\n * @return {boolean}\r\n */\r\nfunction similar (reference, object) {\r\n  let typesMatch;\r\n  let constructorsMatch;\r\n\r\n  constructorsMatch = reference.constructor === object.constructor;\r\n  typesMatch = typeof reference === typeof object;\r\n\r\n  return typesMatch && constructorsMatch\r\n}\n\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals (reference, object) {\r\n  return similar(reference, object) && identical(reference, object)\r\n}\r\n\r\n/**\r\n * Checks to see if two items of the same type and class are the same\r\n * @param identical\r\n *\r\n * @param {object} reference - what is being compared to\r\n * @param {object} object - what is being compared\r\n *\r\n * @return {boolean}\r\n */\r\nfunction identical (reference, object) {\r\n  let every = item =>\r\n    has(reference)(item.key) &&\r\n    has(object)(item.key) &&\r\n    equals(reference[item.key], object[item.key]);\r\n\r\n  // avoid unnecissary recursion\r\n  if (reference.constructor !== Object) {\r\n    return reference === object\r\n  }\r\n\r\n  return flatten([pair(reference), pair(object)]).every(every)\r\n}\n\n/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction exists (it) {\r\n  return it !== undefined && it !== null\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {};\r\n\r\n  function cycle (key, value) {\r\n    let duplicate = () => value === copy && false;\r\n    let effort = () => value === 'function' && attempt(transform, value);\r\n    let needle = () => value === 'object' && inject(value, transform);\r\n\r\n    return [duplicate, effort, needle].find(it => it())() || value\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]); }\r\n\r\n  return copy\r\n}\n\n/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\n\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp;\r\n\r\n  not = inject(it, negated);\r\n  not = inject(not, curry);\r\n  tmp = inject(it, curry);\r\n\r\n  tmp.not = not;\r\n\r\n  return tmp\r\n}\n\n/**\r\n * Detects if the needle is in the haystack.\r\n * @function inside\r\n *\r\n * @param {Object|Array} haystack - what we are looking in\r\n * @param {Object} needle - strict equal comparison compatible\r\n *\r\n * @return {Boolean} Whether or not the value could be located\r\n */\r\nfunction inside (haystack, needle) {\r\n  let toValues = object => key => object[key];\r\n  let isArray = it => it instanceof Array;\r\n  let isObject = it => typeof it === 'object';\r\n  let values = it => Object.keys(it).map(toValues(it));\r\n\r\n  let areInside = it => inside(it, needle);\r\n\r\n  let insideArray = () => haystack.some(areInside);\r\n  let insideObject = () => values(haystack).some(areInside);\r\n\r\n  let array = () => isArray(haystack) && insideArray(haystack, needle);\r\n  let object = () => isObject(haystack) && insideObject(haystack, needle);\r\n  let matches = () => haystack === needle;\r\n  let search = () => array() || object();\r\n\r\n  return matches() || search()\r\n}\n\nlet element = it =>\r\n  it.nodeType === document.ELEMENT_NODE;\r\n\r\nlet fragment = it =>\r\n  it.nodeType === document.DOCUMENT_FRAGMENT_NODE;\r\n\r\nlet text = it =>\r\n  it.nodeType === document.TEXT_NODE;\r\n\r\nlet is = prepare({\r\n  element,\r\n  fragment,\r\n  text,\r\n  inside,\r\n  equal: equals,\r\n  existent: exists\r\n});\n\nexports['default'] = is;\nexports.element = element;\nexports.fragment = fragment;\nexports.text = text;\nexports.equal = equals;\nexports.existent = exists;\n"]}