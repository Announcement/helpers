{"version":3,"sources":["all.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","enough","input","missing","some","ready","transform","params","inputs","context","results","apply","update","fetch","callback","response","arguments","$toProperty","property","object","add","x","y","toProperty","allAre","toLength","toTotal","methods","map","reduce","prepare","from","fromPartial","fromProxy","result","module","exports"],"mappings":"AAAA;;AAEA;;;;;;;;;;;;AAWA,SAASA,OAAT,CAAiBC,KAAjB,EAAwBC,MAAxB,EAAgC;AAC9B,MAAIC,cAAJ;;AAEAF,UAAQA,MAAMG,MAAN,CAAa,EAAb,CAAR;;AAEA,SAAO,CAACD,QAAQF,MAAMI,OAAN,CAAcC,SAAd,CAAT,MAAuC,CAAC,CAAxC,IAA6CJ,OAAOK,MAAP,GAAgB,CAApE,EAAuE;AACrEN,UAAME,KAAN,IAAeD,OAAOM,KAAP,EAAf;AACD;;AAED,SAAOP,MAAMG,MAAN,CAAaF,MAAb,CAAP;AACD;;AAED;;;;;;;;AAQA,SAASD,KAAT,CAAeQ,EAAf,EAAmB;AACjB,SAAOC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BJ,EAA3B,EAA+B,CAA/B,CAAP;AACD;;AAED;;;;;;;;AAQA,SAASK,KAAT,CAAeL,EAAf,EAAmB;AACjB,SAAOA,OAAOH,SAAP,IAAoBG,OAAO,IAAlC;AACD;;AAED;;;;;;;;;AASA,SAASM,KAAT,CAAeC,MAAf,EAAuB;AACrB,MAAIC,SAAS,SAATA,MAAS;AAAA,WAASC,MAAMX,MAAN,GAAeS,OAAOT,MAA/B;AAAA,GAAb;AACA,MAAIY,UAAU,SAAVA,OAAU;AAAA,WAASD,MAAME,IAAN,CAAWN,KAAX,CAAT;AAAA,GAAd;AACA,MAAIO,QAAQ,SAARA,KAAQ;AAAA,WAAMJ,OAAOR,EAAP,KAAc,CAACU,QAAQV,EAAR,CAArB;AAAA,GAAZ;;AAEA,SAAOO,OAAOT,MAAP,IAAiB,CAAjB,GAAqBS,MAArB,GAA8BM,UAAU;;AAE/C;;;;;;;;;;;AAFqC,GAArC,CAaA,SAASA,SAAT,CAAmBC,MAAnB,EAA2B;AACzB,QAAIC,MAAJ;AACA,QAAIC,OAAJ;;AAEA,QAAIC,UAAU,SAAVA,OAAU;AAAA,aAAMV,OAAOW,KAAP,CAAaF,OAAb,EAAsBD,MAAtB,CAAN;AAAA,KAAd;AACA,QAAII,SAAS,SAATA,MAAS;AAAA,aAAMH,WAAWhB,EAAjB;AAAA,KAAb;AACA,QAAIoB,QAAQ,SAARA,KAAQ;AAAA,aAAO,CAACR,MAAMZ,EAAN,CAAD,GAAaa,UAAUb,EAAV,CAAb,GAA6BiB,SAApC;AAAA,KAAZ;;AAEA,WAAOI,QAAP;;AAEA;;;;;;;;AAQA,aAASA,QAAT,GAA4B;AAAA,wCAAPZ,KAAO;AAAPA,aAAO;AAAA;;AAC1B,UAAIa,QAAJ;;AAEAP,eAASxB,QAAQuB,MAAR,EAAgBtB,MAAM+B,SAAN,CAAhB,CAAT;AACAP,gBAAUG,OAAO,IAAP,CAAV;AACAG,iBAAWF,MAAML,MAAN,CAAX;;AAEA,aAAOO,QAAP;AACD;AACF;AACF;;AAED,SAASE,WAAT,CAAqBC,QAArB,EAA+BC,MAA/B,EAAuC;AACrC,SAAOA,OAAOD,QAAP,CAAP;AACD;;AAED,SAASE,GAAT,CAAaC,CAAb,EAAgBC,CAAhB,EAAmB;AACjB,SAAOD,IAAIC,CAAX;AACD;;AAED,IAAIC,aAAaxB,MAAMkB,WAAN,CAAjB;;AAEA,SAASO,MAAT,GAA4B;AAC1B,MAAIjC,MAAJ;;AAEA,MAAIkC,WAAWF,WAAW,QAAX,CAAf;AACA,MAAIG,UAAUN,GAAd;;AAJ0B,qCAATO,OAAS;AAATA,WAAS;AAAA;;AAM1BpC,WAASoC,QAAQC,GAAR,CAAYH,QAAZ,EAAsBI,MAAtB,CAA6BH,OAA7B,CAAT;;AAEA,WAASI,OAAT,CAAiBvB,MAAjB,EAAyB;AACvB,QAAIE,OAAJ;;AAEA,QAAIG,SAAS,SAATA,MAAS;AAAA,aAAMH,WAAWhB,EAAjB;AAAA,KAAb;AACA,QAAIQ,SAAS,SAATA,MAAS;AAAA,aAAMM,OAAOhB,MAAP,GAAgBA,MAAtB;AAAA,KAAb;AACA,QAAIwC,OAAO,SAAPA,IAAO;AAAA,aAAMC,iBAAiBC,WAAvB;AAAA,KAAX;;AAEA,WAAO,YAAkB;AACvB,UAAIC,MAAJ;;AAEAzB,gBAAUG,OAAO,IAAP,CAAV;AACAsB,eAAS,CAACjC,QAAD,IAAa8B,MAAtB;;AAEA,aAAOG,MAAP;AACD,KAPD;AAQD;;AAED,WAASF,WAAT,GAAuB,CAAE;AACzB,WAASC,SAAT,GAAqB,CAAE;;AAEvB,SAAOH,QAAQ,EAAR,CAAP;AACD;;AAEDK,OAAOC,OAAP,GAAiBZ,MAAjB","file":"../all.js","sourcesContent":["'use strict';\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine(array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array(it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty(it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry(method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform(params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => (!ready(it) ? transform(it) : results());\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback(...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\nfunction $toProperty(property, object) {\r\n  return object[property]\r\n}\r\n\r\nfunction add(x, y) {\r\n  return x + y\r\n}\r\n\r\nlet toProperty = curry($toProperty);\r\n\r\nfunction allAre(...methods) {\r\n  var length;\r\n\r\n  let toLength = toProperty('length');\r\n  let toTotal = add;\r\n\r\n  length = methods.map(toLength).reduce(toTotal);\r\n\r\n  function prepare(params) {\r\n    var context;\r\n\r\n    let update = it => context || it;\r\n    let enough = () => params.length < length;\r\n    let from = () => fromPartial() || fromProxy();\r\n\r\n    return function(...args) {\r\n      var result;\r\n\r\n      context = update(this);\r\n      result = !enough() || from();\r\n\r\n      return result\r\n    }\r\n  }\r\n\r\n  function fromPartial() {}\r\n  function fromProxy() {}\r\n\r\n  return prepare([])\r\n}\n\nmodule.exports = allAre;\n"]}