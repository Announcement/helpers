{"version":3,"sources":["equals.js"],"names":["similar","reference","object","typesMatch","constructorsMatch","constructor","equals","module","exports"],"mappings":"AAAA;;;;AAYA,SAASA,OAAT,CAAkBC,SAAlB,EAA6BC,MAA7B,EAAqC;AACnC,MAAIC,mBAAJ;AACA,MAAIC,0BAAJ;;AAEAA,sBAAoBH,UAAUI,WAAV,KAA0BH,OAAOG,WAArD;AACAF,eAAa,QAAOF,SAAP,yCAAOA,SAAP,eAA4BC,MAA5B,yCAA4BA,MAA5B,EAAb;;AAEA,SAAOC,cAAcC,iBAArB;AACD;;AAKD,IAAIE,SAAS,SAATA,MAAS,CAAUL,SAAV,EAAqBC,MAArB,EAA6B;AACxC,MAAI,CAACF,QAAQC,SAAR,EAAmBC,MAAnB,CAAL,EAAiC;AAC/B,WAAO,KAAP;AACD;AAeF,CAlBD;;AAuGAK,OAAOC,OAAP,GAAiBF,MAAjB","file":"../equals.js","sourcesContent":["'use strict';\n\n/**\r\n * Check if they're similar in origin (type & constructor).\r\n *\r\n * @function similar\r\n *\r\n * @param {Object} reference - For comparison reference.\r\n * @param {Object} object - To be compared.\r\n *\r\n * @returns {boolean} True if they have the same type and constructor.\r\n */\nfunction similar (reference, object) {\n  let typesMatch;\n  let constructorsMatch;\n\n  constructorsMatch = reference.constructor === object.constructor;\n  typesMatch = typeof reference === typeof object;\n\n  return typesMatch && constructorsMatch\n}\n\n// import has from './has' // hasOwnProperty\n// import pair from './pair' // {key: value} => [{key: key, value: value}]\n// import flatten from './flatten' // [[[[1]], 2]] => [1, 2]\nvar equals = function (reference, object) {\n  if (!similar(reference, object)) {\n    return false\n  }\n\n  // if (reference.constructor !== Object) {\n  //   return reference === object\n  // }\n\n  // return flatten([\n  //   pair(reference),\n  //   pair(object)\n  // ])\n  // .every(item => {\n  //   return has(reference)(item.key) &&\n  //     has(object)(item.key) &&\n  //     equals(reference[item.key], object[item.key])\n  // })\n};\n\n// function equals (r, o) {\n//   // Are they of the same type?\n//   if (typeof r !== typeof o || r.constructor !== o.constructor) {\n//     return false\n//   }\n//\n//   // Do we need to check recursively?\n//   if (r.constructor !== Object) {\n//     return r === o\n//   }\n//\n//   return flatten([\n//     pair(r),\n//     pair(o)\n//   ])\n//   .every(item => {\n//     return has(r)(item.key) &&\n//       has(o)(item.key) &&\n//       equals(r[item.key], o[item.key])\n//   })\n// }\n//\n// export default equals\n\n\n\n// export default function () {\n//   // this is done to prevent scope/global leakage\n//   return equals.apply(this, arguments)\n//\n//   /**\n//    * Compares reference object to another object.\n//    *\n//    * @function equals\n//    *\n//    * @see has\n//    * @see pair\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - That matches the reference.\n//    *\n//    * @returns {boolean} True, unless they are not equal.\n//    */\n//   function equals (reference, object) {\n//     return similar(reference, object) && identical(reference, object)\n//   }\n//\n//   /**\n//    * Checks to see if two items of the same type and class are the same.\n//    *\n//    * @function identical\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - A similar object to the reference.\n//    *\n//    * @returns {boolean} True, unless reference, object are different type or constructor.\n//    */\n//   function identical (reference, object) {\n//     return test() || pairs()\n//\n//     function test () {\n//       let isObject = () => reference.constructor === Object\n//       let isEqual = () => reference === object\n//\n//       return !isObject() && isEqual()\n//     }\n//\n//     function pairs () {\n//       let asPair = it => pair(it)\n//       let array = [reference, object].map(asPair)\n//\n//       return flatten(array).every(every)\n//     }\n//\n//     function every (item) {\n//       let both = it => has(reference)(it) && has(object)(it)\n//       let match = it => equals(reference[it], object[it])\n//\n//       return !both(item.key) || match(item.key)\n//     }\n//   }\n// }\n\nmodule.exports = equals;\n"]}