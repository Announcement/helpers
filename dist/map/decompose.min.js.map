{"version":3,"sources":["decompose.js"],"names":["array","it","Array","prototype","slice","call","single","list","length","shift","attempt","mutation","subject","parameters","alternative","arguments","apply","this","decompose","initial","composer","previous","current","reducer","reduce","module","exports"],"mappings":"AAAA,aAUA,SAASA,MAAOC,GACd,OAAOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAAI,GAWxC,SAASK,OAAQC,GACf,IACIC,EAKJ,OAHAA,EAASD,EAAKC,OACM,IAAXA,EAAeD,EAAKE,QAAUF,EAiBzC,SAASG,QAASC,EAAUC,GAC1B,IAAIC,OAAAA,EACAC,OAAAA,EAQJ,OALAD,EAAab,MAAMe,WAAWX,MAAM,GACpCU,EAAcR,OAAOO,GAEVF,EAASK,MAAMC,KAAMJ,IAEbC,EAiBrB,SAASI,UAAWlB,EAAOmB,GACzB,IAAIC,EAAW,SAACC,EAAUC,GAAX,OAAuBZ,QAAQY,EAASD,IACnDE,EAAU,SAACtB,GAAD,OAAQD,EAAMwB,OAAOJ,EAAUD,GAAWlB,IAExD,OAAOkB,EAAUI,EAAQJ,GAAWI,EAGtCE,OAAOC,QAAUR","file":"../dist/decompose.min.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * dismantles unnecissary lists\r\n * @method single\r\n *\r\n * @param {Array} list - list of items\r\n *\r\n * @return {Array|Object}\r\n */\r\nfunction single (list) {\r\n  var result;\r\n  var length;\r\n\r\n  length = list.length;\r\n  result = length === 1 ? list.shift() : list;\r\n\r\n  return result\r\n}\n\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters;\r\n  let alternative;\r\n  let response;\r\n\r\n  parameters = array(arguments).slice(1);\r\n  alternative = single(parameters);\r\n\r\n  response = mutation.apply(this, parameters);\r\n\r\n  return response || alternative\r\n}\n\n/**\r\n * Applies functions to a value and moves down the chain if possible\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array$\r\n *\r\n * @param {Array} array - list of functions to be applied\r\n * @param {Object} initial - optional initial item\r\n *\r\n * @return Object\r\n */\r\nfunction decompose (array, initial) {\r\n  let composer = (previous, current) => attempt(current, previous);\r\n  let reducer = (it) => array.reduce(composer, initial || it);\r\n\r\n  return initial ? reducer(initial) : reducer\r\n}\n\nmodule.exports = decompose;\n"]}