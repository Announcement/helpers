{"version":3,"sources":["query.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","empty","curry","method","transform","params","callback","_len","arguments","input","_key","inputs","context","update","this","fetch","results","apply","ready","enough","missing","some","where","reference","object","keys","every","key","Object","select","compliant","prepare","normalize","isArray","pull","item","response","forEach","param","merge","ensure","listed","filter","append","query","search","_where","findIndex","push","reducer","previous","current","_len2","_key2","beforeReduce","defineProperty","exports","value","unique","normal","reduce","find"],"mappings":"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","file":"../dist/query.min.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index;\r\n\r\n  array = array.concat([]);\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift();\r\n  }\r\n\r\n  return array.concat(values)\r\n}\n\n/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\n\n/**\r\n * Checks to see if an item is null or undefined)\r\n * @function empty\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction empty (it) {\r\n  return it === undefined || it === null\r\n}\n\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  let enough = input => input.length < method.length;\r\n  let missing = input => input.some(empty);\r\n  let ready = it => enough(it) && !missing(it);\r\n\r\n  return method.length <= 1 ? method : transform([])\r\n\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {(Function|Object)} intercepted output piped from source curry method\r\n  */\r\n  function transform (params) {\r\n    var inputs;\r\n    var context;\r\n\r\n    let results = () => method.apply(context, inputs);\r\n    let update = it => context || it;\r\n    let fetch = it => !ready(it) ? transform(it) : results();\r\n\r\n    return callback\r\n\r\n    /**\r\n     * Interception layer to revert back to transform if data is missing\r\n     * @function callback\r\n     *\r\n     * @param {Array} input - all of the variables to be accepted by method\r\n     *\r\n     * @returns {Object} piped output from source curry method\r\n     **/\r\n    function callback (...input) {\r\n      var response;\r\n\r\n      inputs = combine(params, array(arguments));\r\n      context = update(this);\r\n      response = fetch(inputs);\r\n\r\n      return response\r\n    }\r\n  }\r\n}\n\n/**\r\n * useful inside of a pipeline\r\n * @method where\r\n * @version 3.0.0\r\n *\r\n * @param {Object.<string, string>} search - object with properties to match\r\n *\r\n * @return {boolean}\r\n */\r\nfunction where (reference, object) {\r\n  var keys;\r\n  var result;\r\n\r\n  let every = key => reference[key] === object[key];\r\n\r\n  keys = Object.keys(reference);\r\n  result = keys.every(every);\r\n\r\n  return result\r\n}\r\n\r\nvar _where = curry(where);\n\nlet isArray = it => it instanceof Array;\r\n\r\n/**\r\n * intended to be used with Array.prototype.reduce\r\n * @method select\r\n * @version 2.0.0\r\n *\r\n * @param {...string} property - property to pull from each object\r\n *\r\n * @return {function}\r\n */\r\nfunction select (...params) {\r\n  function compliant (it, key) {\r\n    return params.indexOf(key) !== -1 ? it[key] : [it[key]]\r\n  }\r\n\r\n  function prepare (it) {\r\n    for (var key in it) {\r\n      it[key] = compliant(it, key);\r\n    }\r\n\r\n    return it\r\n  }\r\n\r\n  function normalize (it) {\r\n    if (!isArray(it)) {\r\n      return [prepare(it)]\r\n    }\r\n\r\n    return it\r\n  }\r\n\r\n  function pull (item) {\r\n    var response;\r\n\r\n    let forEach = param => {\r\n      response[param] = item[param];\r\n    };\r\n\r\n    response = {};\r\n\r\n    params.forEach(forEach);\r\n\r\n    return response\r\n  }\r\n\r\n  function merge (reference, object) {\r\n    var keys;\r\n\r\n    let ensure = key => {\r\n      reference[key] = reference[key] || [];\r\n    };\r\n    let concat = key => {\r\n      reference[key] = reference[key].concat(object[key]);\r\n    };\r\n    let listed = key => params.indexOf(key) === -1;\r\n\r\n    keys = Object.keys(object).filter(listed);\r\n\r\n    keys.forEach(ensure);\r\n    keys.forEach(concat);\r\n\r\n    return reference\r\n  }\r\n\r\n  function append (array, item) {\r\n    var index;\r\n    var query;\r\n    var search;\r\n\r\n    query = pull(item);\r\n    search = _where(query);\r\n    index = array.findIndex(search);\r\n\r\n    if (index !== -1) {\r\n      array[index] = merge(array[index], item);\r\n    } else {\r\n      array.push(item);\r\n    }\r\n\r\n    return array\r\n  }\r\n\r\n  function reducer (previous, current) {\r\n    var array;\r\n    var item;\r\n\r\n    array = normalize(previous);\r\n    item = prepare(current);\r\n\r\n    array = append(array, item);\r\n\r\n    return array\r\n  }\r\n\r\n  return reducer\r\n}\n\nfunction beforeReduce (it) {\r\n  return it instanceof Array ? it : [it]\r\n}\r\n\r\n// normal is the most convenient implementation\r\n// filter is the most efficient implementation\r\n// reduce is the most reliable implementation\r\n\r\nlet unique = {\r\n  normal: curry(function normal (array, value) {\r\n    return array.filter(_where(value)).length > 1\r\n  }),\r\n\r\n  filter: function filter (value, index, array) {\r\n    return array.indexOf(value, index + 1) === -1\r\n  },\r\n\r\n  reduce: function reduce (previous, current) {\r\n    previous = beforeReduce(previous);\r\n\r\n    if (!previous.find(_where(current))) {\r\n      previous.push(current);\r\n    }\r\n\r\n    return previous\r\n  }\r\n};\n\nexports.where = _where;\nexports.select = select;\nexports.unique = unique;\n"]}