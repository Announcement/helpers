{"version":3,"sources":["prepare.js"],"names":["array","it","Array","prototype","slice","call","single","list","result","isArray","alone","length","shift","exists","undefined","attempt","mutation","subject","parameters","apply","method","valid","arguments","inject","transform","copy","keys","isObject","constructor","name","isFunction","forObject","forFunction","Object","forEach","key","value","combine","values","index","concat","indexOf","empty","curry","enough","input","missing","some","ready","inputs","context","results","update","fetch","callback","response","negated","prepare","not","tmp","module","exports"],"mappings":"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","file":"../prepare.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\n/**\n * Injects a transformer into each element of a collection.\n *\n * @function inject\n *\n * @see attempt\n *\n * @param {Object.<string, Function>} it - Collection of functions.\n * @param {Function} transform - Mutator function to run through each of the functions in it.\n *\n * @returns {Object.<string, Function>} All it functions, but mutated via transform.\n */\nfunction inject (it, transform) {\n  var copy;\n  var keys;\n\n  let isObject = it =>\n    typeof it === 'object' && it.constructor.name === 'Object';\n\n  let isFunction = it =>\n    typeof it === 'function' && it.constructor.name === 'Function';\n\n  let forObject = it =>\n    isObject(it) && inject(it, transform);\n\n  let forFunction = it =>\n    isFunction(it) && attempt(transform, it);\n\n  keys = Object.keys(it);\n  copy = {};\n\n  keys.forEach(forEach);\n\n  return copy\n\n  function forEach (key) {\n    var value;\n\n    value = it[key];\n\n    value = attempt(forObject, value);\n    value = attempt(forFunction, value);\n\n    copy[key] = value;\n  }\n}\n\n/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end.\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - List of existing items.\r\n * @param {Array} values - Proposed additions to the list.\r\n *\r\n * @returns {Array} - Collective array.\r\n */\nvar combine = function (array, values) {\n  let index;\n\n  array = array.concat([]);\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift();\n  }\n\n  return array.concat(values)\n};\n\n/**\r\n * Check to see if an item is null or undefined.\r\n *\r\n * @function empty\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} False, unless it is null or undefiend.\r\n */\nvar empty = function (it) {\n  return it === undefined || it === null\n};\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nvar curry = function (method) {\n  let enough = input => input.length >= method.length;\n  let missing = input => input.some(empty);\n  let ready = it => enough(it) && !missing(it);\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs;\n    var context;\n\n    let results = () => method.apply(context, inputs);\n    let update = it => context || it;\n    let fetch = it => !ready(it) ? transform(it) : results();\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response;\n\n      inputs = combine(parameters, array(arguments));\n      context = update(this);\n      response = fetch(inputs);\n\n      return response\n    }\n  }\n};\n\n/**\r\n * Returns a modified version of a function with negated boolean output.\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - Method to be negated.\r\n *\r\n * @returns {Function} Function with inverse output.\r\n */\nfunction negated (it) {\n  return function () {\n    return !it.apply(this, arguments)\n  }\n}\n\nfunction prepare (it) {\n  var not;\n  var tmp;\n\n  not = inject(it, negated);\n  not = inject(not, curry);\n  tmp = inject(it, curry);\n\n  tmp.not = not;\n\n  return tmp\n}\n\nmodule.exports = prepare;\n"]}