{"version":3,"sources":["attempt.js"],"names":["array","it","Array","prototype","slice","call","single","list","result","isArray","alone","length","shift","exists","undefined","attempt","mutation","subject","parameters","apply","method","valid","arguments","module","exports"],"mappings":"AAAA;;;;AAWA,IAAIA,QAAQ,SAARA,KAAQ,CAAUC,EAAV,EAAc;AACxB,SAAOC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BJ,EAA3B,EAA+B,CAA/B,CAAP;AACD,CAFD;;AAaA,SAASK,MAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAIC,MAAJ;;AAEA,MAAIC,UAAU,SAAVA,OAAU,CAACR,EAAD;AAAA,WAAQ,QAAOA,EAAP,yCAAOA,EAAP,OAAc,QAAd,IAA0BA,cAAcC,KAAhD;AAAA,GAAd;AACA,MAAIQ,QAAQ,SAARA,KAAQ;AAAA,WAAMD,QAAQR,EAAR,KAAeA,GAAGU,MAAH,KAAc,CAAnC;AAAA,GAAZ;;AAEAH,WAASE,MAAMH,IAAN,IAAcA,KAAKK,KAAL,EAAd,GAA6BL,IAAtC;;AAEA,SAAOC,MAAP;AACD;;AAWD,SAASK,MAAT,CAAiBZ,EAAjB,EAAqB;AACnB,SAAOA,OAAOa,SAAP,IAAoBb,OAAO,IAAlC;AACD;;AAgBD,IAAIc,UAAU,SAAVA,OAAU,CAAUC,QAAV,EAAoBC,OAApB,EAA6B;AAAA;;AACzC,MAAIC,UAAJ;AACA,MAAIV,MAAJ;;AAEA,MAAIW,QAAQ,SAARA,KAAQ,CAACC,MAAD,EAASF,UAAT;AAAA,WAAwBE,OAAOD,KAAP,QAAmBD,UAAnB,CAAxB;AAAA,GAAZ;AACA,MAAIG,QAAQ,SAARA,KAAQ;AAAA,WAAMR,OAAOZ,EAAP,KAAcK,OAAOL,EAAP,CAApB;AAAA,GAAZ;;AAEAiB,eAAalB,MAAMsB,SAAN,EAAiBlB,KAAjB,CAAuB,CAAvB,CAAb;AACAI,WAASW,MAAMH,QAAN,EAAgBE,UAAhB,CAAT;;AAEA,SAAOG,MAAMb,MAAN,KAAiBa,MAAMH,UAAN,CAAxB;AACD,CAXD;;AAaAK,OAAOC,OAAP,GAAiBT,OAAjB","file":"../attempt.js","sourcesContent":["'use strict';\n\n/**\r\n * Lazy way of turning an item into an Array.\r\n *\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object.\r\n *\r\n * @returns {Array} Implicit array object.\r\n */\nvar array = function (it) {\n  return Array.prototype.slice.call(it, 0)\n};\n\n/**\r\n * Dismantles unnecissary lists.\r\n *\r\n * @function single\r\n *\r\n * @param {Array} list - List of items.\r\n *\r\n * @returns {Array|Object} The only item or entire list.\r\n */\nfunction single (list) {\n  var result;\n\n  let isArray = (it) => typeof it === 'object' && it instanceof Array;\n  let alone = it => isArray(it) && it.length === 1;\n\n  result = alone(list) ? list.shift() : list;\n\n  return result\n}\n\n/**\r\n * Checks to see if an item exists.\r\n *\r\n * @function exists\r\n *\r\n * @param {Object} it - The item in question of existance.\r\n *\r\n * @returns {boolean} True, unless it is null or undefined.\r\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\r\n * Attempts to apply mutation to subject.\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n * @see single\r\n * @see exists\r\n *\r\n * @param {Function} mutation - Mutator function to be called on the subject.\r\n * @param {Object} subject - Any input that should be mutated.\r\n *\r\n * @returns {Object} Subject unless mutation can be applied.\r\n */\nvar attempt = function (mutation, subject) {\n  var parameters;\n  var result;\n\n  let apply = (method, parameters) => method.apply(this, parameters);\n  let valid = it => exists(it) && single(it);\n\n  parameters = array(arguments).slice(1);\n  result = apply(mutation, parameters);\n\n  return valid(result) || valid(parameters)\n};\n\nmodule.exports = attempt;\n"]}