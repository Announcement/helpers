'use strict'
function combine (n, t) {
  var e = void 0
  for (n = n.concat([]); (e = n.indexOf(void 0)) !== -1 && t.length > 0;) { n[e] = t.shift() }
  return n.concat(t)
}
function array (n) {
  return Array.prototype.slice.call(n, 0)
}
function empty (n) {
  return void 0 === n || n === null
}
function curry (n) {
  function t (e) {
    function r () {
      for (var n = arguments.length, t = Array(n), r = 0; r < n; r++) { t[r] = arguments[r] }
      return o = combine(e, array(arguments)), i = f(this), a(o)
    }
    var o,
      i,
      c = function () {
        return n.apply(i, o)
      },
      f = function (n) {
        return i || n
      },
      a = function (n) {
        return u(n) ? c() : t(n)
      }
    return r
  }
  var e = function (t) {
      return t.length < n.length
    },
    r = function (n) {
      return n.some(empty)
    },
    u = function (n) {
      return e(n) && !r(n)
    }
  return n.length <= 1 ? n : t([])
}
function pair (n) {
  return Object.keys(n).map(function (t) {
    return { key: t, value: n[t] }
  })
}
function flatten (n) {
  var t = void 0, e = void 0, r = void 0
  for (t = function (n) {
    return n.constructor === Array
  }, e = function (n) {
    return t(n) ? n : [ n ]
  }, r = function (n, t) {
    return n.concat(t)
  }; n.some(t);) { n = n.map(e).reduce(r) }
  return n
}
function similar (n, t) {
  var e = void 0
  return e = n.constructor === t.constructor, (void 0 === n
    ? 'undefined'
    : _typeof(n)) ===
    (void 0 === t ? 'undefined' : _typeof(t)) &&
    e
}
function equals (n, t) {
  return similar(n, t) && identical(n, t)
}
function identical (n, t) {
  var e = function (e) {
    return has(n)(e.key) && has(t)(e.key) && equals(n[e.key], t[e.key])
  }
  return n.constructor !== Object
    ? n === t
    : flatten([ pair(n), pair(t) ]).every(e)
}
function exists (n) {
  return void 0 !== n && n !== null
}
function single (n) {
  var t
  return t = n.length, t === 1 ? n.shift() : n
}
function attempt (n, t) {
  var e = void 0, r = void 0
  return e = array(arguments).slice(1), r = single(e), n.apply(this, e) || r
}
function inject (n, t) {
  var e = {}
  for (var r in n) {
    e[r] = (function (n, r) {
      return [
        function () {
          return r === e && !1
        },
        function () {
          return r === 'function' && attempt(t, r)
        },
        function () {
          return r === 'object' && inject(r, t)
        }
      ].find(function (n) {
        return n()
      })() || r
    }(r, n[r]))
  }
  return e
}
function negated (n) {
  return function () {
    return !n.apply(this, arguments)
  }
}
function prepare (n) {
  var t = void 0, e = void 0
  return t = inject(n, negated), t = inject(t, curry), e = inject(
    n,
    curry
  ), e.not = t, e
}
function inside (n, t) {
  var e = function (n) {
      return function (t) {
        return n[t]
      }
    },
    r = function (n) {
      return n instanceof Array
    },
    u = function (n) {
      return (void 0 === n ? 'undefined' : _typeof(n)) === 'object'
    },
    o = function (n) {
      return Object.keys(n).map(e(n))
    },
    i = function (n) {
      return inside(n, t)
    },
    c = function () {
      return n.some(i)
    },
    f = function () {
      return o(n).some(i)
    },
    a = function () {
      return r(n) && c()
    },
    s = function () {
      return u(n) && f()
    }
  return (function () {
    return n === t
  }()) || (function () {
    return a() || s()
  }())
}
var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
  ? function (n) {
    return typeof n
  }
  : function (n) {
    return n && typeof Symbol === 'function' && n.constructor === Symbol &&
      n !== Symbol.prototype
      ? 'symbol'
      : typeof n
  }
Object.defineProperty(exports, '__esModule', { value: !0 })
var has = curry(function (n, t) {
    return n.hasOwnProperty(t)
  }),
  element = function (n) {
    return n.nodeType === document.ELEMENT_NODE
  },
  fragment = function (n) {
    return n.nodeType === document.DOCUMENT_FRAGMENT_NODE
  },
  text = function (n) {
    return n.nodeType === document.TEXT_NODE
  },
  is = prepare({
    element: element,
    fragment: fragment,
    text: text,
    inside: inside,
    equal: equals,
    existent: exists
  })
exports.default = is, exports.element = element, exports.fragment = fragment, exports.text = text, exports.equal = equals, exports.existent = exists
// # sourceMappingURL=../map/is.min.js.map
