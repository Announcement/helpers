{"version":3,"sources":["equals.js"],"names":["reference","object","constructor","Object","every","item","key","equals"],"mappings":";;;;;;kBAKe,UAAUA,SAAV,EAAqBC,MAArB,EAA6B;AAC1C,MAAI,CAAC,uBAAQD,SAAR,EAAmBC,MAAnB,CAAL,EAAiC;AAC/B,WAAO,KAAP;AACD;;AAED,MAAID,UAAUE,WAAV,KAA0BC,MAA9B,EAAsC;AACpC,WAAOH,cAAcC,MAArB;AACD;;AAED,SAAO,uBAAQ,CACb,oBAAKD,SAAL,CADa,EAEb,oBAAKC,MAAL,CAFa,CAAR,EAING,KAJM,CAIAC,QAAQ;AACb,WAAO,mBAAIL,SAAJ,EAAeK,KAAKC,GAApB,KACL,mBAAIL,MAAJ,EAAYI,KAAKC,GAAjB,CADK,IAELC,OAAOP,UAAUK,KAAKC,GAAf,CAAP,EAA4BL,OAAOI,KAAKC,GAAZ,CAA5B,CAFF;AAGD,GARM,CAAP;AASD,C;;AAvBD;;;;AACA;;;;AACA;;;;AACA","file":"../equals.js","sourcesContent":["import has from './has' // hasOwnProperty\nimport pair from './pair' // {key: value} => [{key: key, value: value}]\nimport flatten from './flatten' // [[[[1]], 2]] => [1, 2]\nimport similar from './similar' // (typeof && constructor) match\n\nexport default function (reference, object) {\n  if (!similar(reference, object)) {\n    return false\n  }\n\n  if (reference.constructor !== Object) {\n    return reference === object\n  }\n\n  return flatten([\n    pair(reference),\n    pair(object)\n  ])\n  .every(item => {\n    return has(reference)(item.key) &&\n      has(object)(item.key) &&\n      equals(reference[item.key], object[item.key])\n  })\n}\n\n// function equals (r, o) {\n//   // Are they of the same type?\n//   if (typeof r !== typeof o || r.constructor !== o.constructor) {\n//     return false\n//   }\n//\n//   // Do we need to check recursively?\n//   if (r.constructor !== Object) {\n//     return r === o\n//   }\n//\n//   return flatten([\n//     pair(r),\n//     pair(o)\n//   ])\n//   .every(item => {\n//     return has(r)(item.key) &&\n//       has(o)(item.key) &&\n//       equals(r[item.key], o[item.key])\n//   })\n// }\n//\n// export default equals\n\n\n\n// export default function () {\n//   // this is done to prevent scope/global leakage\n//   return equals.apply(this, arguments)\n//\n//   /**\n//    * Compares reference object to another object.\n//    *\n//    * @function equals\n//    *\n//    * @see has\n//    * @see pair\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - That matches the reference.\n//    *\n//    * @returns {boolean} True, unless they are not equal.\n//    */\n//   function equals (reference, object) {\n//     return similar(reference, object) && identical(reference, object)\n//   }\n//\n//   /**\n//    * Checks to see if two items of the same type and class are the same.\n//    *\n//    * @function identical\n//    *\n//    * @param {Object} reference - What should be compared to.\n//    * @param {Object} object - A similar object to the reference.\n//    *\n//    * @returns {boolean} True, unless reference, object are different type or constructor.\n//    */\n//   function identical (reference, object) {\n//     return test() || pairs()\n//\n//     function test () {\n//       let isObject = () => reference.constructor === Object\n//       let isEqual = () => reference === object\n//\n//       return !isObject() && isEqual()\n//     }\n//\n//     function pairs () {\n//       let asPair = it => pair(it)\n//       let array = [reference, object].map(asPair)\n//\n//       return flatten(array).every(every)\n//     }\n//\n//     function every (item) {\n//       let both = it => has(reference)(it) && has(object)(it)\n//       let match = it => equals(reference[it], object[it])\n//\n//       return !both(item.key) || match(item.key)\n//     }\n//   }\n// }\n"]}