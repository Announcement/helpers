{"version":3,"sources":["curry.js"],"names":["method","enough","input","length","missing","some","ready","it","transform","parameters","inputs","context","results","apply","update","fetch","callback","response","arguments"],"mappings":";;;;;;kBAiBe,UAAUA,MAAV,EAAkB;AAC/B,MAAIC,SAASC,SAASA,MAAMC,MAAN,IAAgBH,OAAOG,MAA7C;AACA,MAAIC,UAAUF,SAASA,MAAMG,IAAN,iBAAvB;AACA,MAAIC,QAAQC,MAAMN,OAAOM,EAAP,KAAc,CAACH,QAAQG,EAAR,CAAjC;;AAEA,SAAOP,OAAOG,MAAP,IAAiB,CAAjB,GAAqBH,MAArB,GAA8BQ,UAAU;;AAEhD;;;;;;;;;AAFsC,GAArC,CAWA,SAASA,SAAT,CAAoBC,UAApB,EAAgC;AAC9B,QAAIC,MAAJ;AACA,QAAIC,OAAJ;;AAEA,QAAIC,UAAU,MAAMZ,OAAOa,KAAP,CAAaF,OAAb,EAAsBD,MAAtB,CAApB;AACA,QAAII,SAASP,MAAMI,WAAWJ,EAA9B;AACA,QAAIQ,QAAQR,MAAM,CAACD,MAAMC,EAAN,CAAD,GAAaC,UAAUD,EAAV,CAAb,GAA6BK,SAA/C;;AAEA,WAAOI,QAAP;;AAEA;;;;;;;;;AASA,aAASA,QAAT,CAAmB,GAAGd,KAAtB,EAA6B;AAC3B,UAAIe,QAAJ;;AAEAP,eAAS,uBAAQD,UAAR,EAAoB,qBAAMS,SAAN,CAApB,CAAT;AACAP,gBAAUG,OAAO,IAAP,CAAV;AACAG,iBAAWF,MAAML,MAAN,CAAX;;AAEA,aAAOO,QAAP;AACD;AACF;AACF,C;;AA9DD;;;;AACA;;;;AACA","file":"../curry.js","sourcesContent":["import combine from './combine'\nimport array from './array'\nimport empty from './empty'\n\n/**\r\n * Returns a modified function with lazy option assocations.\r\n *\r\n * @function curry\r\n *\r\n * @see combine\r\n * @see array\r\n * @see empty\r\n *\r\n * @param {Function} method - Function to be curried.\r\n *\r\n * @returns {Function} Curried functions.\r\n */\nexport default function (method) {\n  let enough = input => input.length >= method.length\n  let missing = input => input.some(empty)\n  let ready = it => enough(it) && !missing(it)\n\n  return method.length <= 1 ? method : transform([])\n\n /**\r\n  * Generated method through currying, allowing chainibility.\r\n  *\r\n  * @function transform\r\n  *\r\n  * @param {Array} parameters - Array of arguments.\r\n  *\r\n  * @returns {(Function|Object)} Intercepted output piped from source curry method.\r\n  */\n  function transform (parameters) {\n    var inputs\n    var context\n\n    let results = () => method.apply(context, inputs)\n    let update = it => context || it\n    let fetch = it => !ready(it) ? transform(it) : results()\n\n    return callback\n\n    /**\r\n     * Interception layer to revert back to transform if data is missing.\r\n     *\r\n     * @function callback\r\n     *\r\n     * @param {...Array} input - All of the variables to be accepted by method.\r\n     *\r\n     * @returns {Object} Output of the source curry method.\r\n     **/\n    function callback (...input) {\n      var response\n\n      inputs = combine(parameters, array(arguments))\n      context = update(this)\n      response = fetch(inputs)\n\n      return response\n    }\n  }\n}\n"]}