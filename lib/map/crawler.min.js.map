{"version":3,"sources":["crawler.js"],"names":["decompose","processors","input","each","it","test","item","_first2","default","console","log","unit","_first","require","isArray","constructor","Array","isObject","Object","map","callback","object","assign","key","value","output","Crawler","method","this","cache","unique","indexOf","push","flat","render","response","genericProcessor","result","process","bind","descend"],"mappings":"qFAoBA,SAASA,UAAWC,EAAYC,GAC9B,IAAIC,EAAOC,GAAMA,EAAGC,KAAKH,GACrBI,GAAO,EAAAC,QAAAC,SAAMP,EAAYE,GAI7B,OAFAM,QAAQC,IAAIJ,GAEJA,EAAeA,EAAKJ,MAAMS,KAAKT,GAAxBA,gFAzBjB,IAAAU,OAAAC,QAAA,kDAGA,IAAIC,QAAWV,GAAOA,EAAGW,cAAgBC,MACrCC,SAAYb,GAAOA,EAAGW,cAAgBG,OAEtCC,IAAM,CAACf,EAAIgB,KACb,MAAMC,EAASH,OAAOI,UAAWlB,GAEjC,IAAK,IAAKmB,EAAKC,KAAUH,EACvBA,EAAOE,IACLrB,MAAOsB,EACPC,OAAQL,EAASI,EAAOD,EAAKnB,IAIjC,OAAOiB,SAYHK,QACJX,YAAaY,GACXC,KAAKD,OAASA,EACdC,KAAKC,SAGPC,OAAQN,GACN,IAAIK,EAAQD,KAAKC,MAEjB,OAA8B,IAA1BA,EAAME,QAAQP,KAIlBK,EAAMG,KAAKR,IACJ,GAGTS,KAAM7B,EAAIgB,mBAGR,IAAIc,EAAUV,EAAYH,EAAbE,EAAwBF,GACnCZ,QAAI0B,IAAAA,GACJ1B,OAAAA,SAKF,IAAI2B,EAAAA,IAAAA,GAAoBhC,GACtBK,QAAI4B,IAAAA,mBAAJA,GACA5B,OAAAA,GASF,2GAIF6B,IAAAA,EAAAlC,GACMgC,KAAAA,KAAAA,EAAmBhC,KAAAA,QAAMmC,KAAAX,mIAgB/BY,MAASpC,EAAIwB,KAAAD,OACIC,KAAKD,QAApBY,KAAAX","file":"../lib/crawler.min.js","sourcesContent":["// import exists from './exists'\r\nimport first from './first'\r\n// import {forEach} from './loop'\r\n\r\nlet isArray = (it) => it.constructor === Array\r\nlet isObject = (it) => it.constructor === Object\r\n\r\nlet map = (it, callback) => {\r\n  const object = Object.assign({}, it)\r\n\r\n  for (let [key, value] of object) {\r\n    object[key] = {\r\n      input: value,\r\n      output: callback(value, key, it)\r\n    }\r\n  }\r\n\r\n  return object\r\n}\r\n\r\nfunction decompose (processors, input) {\r\n  let each = it => it.test(input)\r\n  let item = first(processors, each)\r\n\r\n  console.log(item)\r\n\r\n  return !item ? input : item.input.unit(input)\r\n}\r\n\r\nclass Crawler {\r\n  constructor (method) {\r\n    this.method = method\r\n    this.cache = []\r\n  }\r\n\r\n  unique (value) {\r\n    let cache = this.cache\r\n\r\n    if (cache.indexOf(value) !== -1) {\r\n      return false\r\n    }\r\n\r\n    cache.push(value)\r\n    return true\r\n  }\r\n\r\n  flat (it, callback) {\r\n    // const unique = this.unique.bind(this)\r\n\r\n    let render = (value, key, object) => {\r\n      let response = callback(value, key, object)\r\n      console.log(response)\r\n      return response\r\n      // results.push(result)?\r\n    }\r\n\r\n    let genericProcessor = (it) => {\r\n      let result = map(it)(render)\r\n      console.log('render processor', result)\r\n      return result\r\n    }\r\n\r\n    let processors = [\r\n      {name: 'array', test: isArray, unit: genericProcessor},\r\n      {name: 'object', test: isObject, unit: genericProcessor}\r\n    ]\r\n\r\n    let response = decompose(processors, it)\r\n    return response\r\n  }\r\n\r\n  process (object, callback) {\r\n    let genericProcessor = it => {\r\n      return this.flat(it, this.process.bind(this))\r\n    }\r\n\r\n    let processors = [\r\n      {name: 'array', test: isArray, unit: genericProcessor},\r\n      {name: 'object', test: isObject, unit: genericProcessor}\r\n    ]\r\n\r\n    let response = decompose(processors, object)\r\n\r\n    console.log(response)\r\n\r\n    return response\r\n  }\r\n\r\n  descend (it) {\r\n    const method = this.method\r\n    const process = this.process.bind(this)\r\n\r\n    process(it, method)\r\n  }\r\n}\r\n\r\nexport {Crawler as default}\r\n"]}