{"version":3,"file":"selfish.js","sources":["../src/exists.js","../src/array.js","../src/attempt.js","../src/inject.js","../src/combine.js","../src/curry.js","../src/negated.js","../src/prepare.js","../src/selfish.js"],"sourcesContent":["/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nexport default function exists (it) {\r\n  return it !== undefined && it !== null\r\n}\r\n","/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\r\n\r\nexport {array as default}\r\n","import array from './array'\r\n\r\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters\r\n  let alternative\r\n  let response\r\n\r\n  parameters = array(arguments).slice(1)\r\n  alternative = parameters.length === 1 ? parameters[0] : parameters\r\n\r\n  response = mutation.apply(this, parameters)\r\n\r\n  return response || alternative\r\n}\r\n\r\nexport {attempt as default}\r\n","import attempt from './attempt'\r\n\r\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {}\r\n\r\n  function cycle (key, value) {\r\n    if (value === copy) { return false }\r\n\r\n    if (typeof value === 'function') { return attempt(transform, value) }\r\n\r\n    if (typeof value === 'object') { return inject(value, transform) }\r\n\r\n    // return value;\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]) }\r\n\r\n  return copy\r\n}\r\n\r\nexport {inject as default}\r\n","/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index\r\n\r\n  array = array.concat([])\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift()\r\n  }\r\n\r\n  return array.concat(values)\r\n}\r\n\r\nexport {combine as default}\r\n","import combine from './combine'\r\nimport array from './array'\r\n\r\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {Object} piped output from source curry method\r\n  */\r\n  function transform (params) {\r\n    let context\r\n\r\n    return function (...input) {\r\n      let args = combine(params, array(arguments))\r\n\r\n      context = context || this\r\n\r\n      if (args.length < method.length || args.some((it) => it === undefined)) {\r\n        return transform(args)\r\n      } else {\r\n        return method.apply(context, args)\r\n      }\r\n    }\r\n  }\r\n  return method.length <= 1 ? method : transform([])\r\n}\r\n\r\nexport {curry as default}\r\n","/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\r\n\r\nexport {negated as default}\r\n","import inject from './inject'\r\nimport curry from './curry'\r\nimport negated from './negated'\r\n\r\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp\r\n\r\n  not = inject(it, negated)\r\n  not = inject(not, curry)\r\n  tmp = inject(it, curry)\r\n\r\n  tmp.not = not\r\n\r\n  return tmp\r\n}\r\n\r\nexport {prepare as default}\r\n","import exists from './exists'\r\nimport prepare from './prepare'\r\n\r\nlet is = prepare({existent: exists})\r\n\r\nexport {\r\n  is as default\r\n}\r\n"],"names":["exists","it","undefined","array","Array","prototype","slice","call","attempt","mutation","subject","parameters","alternative","response","arguments","length","apply","inject","transform","copy","cycle","key","value","combine","values","index","concat","indexOf","shift","curry","method","params","context","input","args","some","negated","prepare","not","tmp","is","existent"],"mappings":"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"}