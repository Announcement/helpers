{"version":3,"file":"helpers.js","sources":["../src/combine.js","../src/array.js","../src/curry.js","../src/has.js","../src/pair.js","../src/flatten.js","../src/equals.js","../src/exists.js","../src/attempt.js","../src/inject.js","../src/negated.js","../src/prepare.js","../src/is.js","../src/decompose.js","../src/as.js","../src/helpers.js"],"sourcesContent":["/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index\r\n\r\n  array = array.concat([])\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift()\r\n  }\r\n\r\n  return array.concat(values)\r\n}\r\n\r\nexport {combine as default}\r\n","/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n};\r\n\r\nexport {array as default}\r\n","import combine from './combine'\r\nimport array from './array'\r\n\r\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {Object} piped output from source curry method\r\n  */\r\n  function transform (params) {\r\n    let context\r\n\r\n    return function (...input) {\r\n      let args = combine(params, array(arguments))\r\n\r\n      context = context || this\r\n\r\n      if (args.length < method.length || args.some((it) => it === undefined)) {\r\n        return transform(args)\r\n      } else {\r\n        return method.apply(context, args)\r\n      }\r\n    }\r\n  }\r\n  return method.length <= 1 ? method : transform([])\r\n}\r\n\r\nexport {curry as default}\r\n","import curry from './curry'\r\n\r\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n})\r\n\r\nexport {has as default}\r\n","/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{name: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\r\n\r\nexport {pair as default}\r\n","/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray\r\n  let toArray\r\n  let fromArray\r\n\r\n  isArray = (it) => it.constructor === Array\r\n  toArray = (it) => isArray(it) ? it : [it]\r\n  fromArray = (a, b) => a.concat(b)\r\n\r\n  while (array.some(isArray)) { array = array.map(toArray).reduce(fromArray) }\r\n\r\n  return array\r\n}\r\n\r\nexport {flatten as default}\r\n","import has from './has'\r\nimport pair from './pair'\r\nimport flatten from './flatten'\r\n\r\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals (r, o) {\r\n  // Are they of the same type?\r\n  if (typeof r !== typeof o || r.constructor !== o.constructor) {\r\n    return false\r\n  }\r\n\r\n  // Do we need to check recursively?\r\n  if (r.constructor !== Object) {\r\n    return r === o\r\n  }\r\n\r\n  return flatten([\r\n    pair(r),\r\n    pair(o)\r\n  ])\r\n  .every(item => {\r\n    return has(r)(item.key) &&\r\n      has(o)(item.key) &&\r\n      equals(r[item.key], o[item.key])\r\n  })\r\n}\r\n\r\nexport {equals as default}\r\n","/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nfunction exists (it) {\r\n  return it !== undefined && it !== null\r\n}\r\n\r\nexport {exists as default}\r\n","import array from './array'\r\n\r\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters\r\n  let alternative\r\n  let response\r\n\r\n  parameters = array(arguments).slice(1)\r\n  alternative = parameters.length === 1 ? parameters[0] : parameters\r\n\r\n  response = mutation.apply(this, parameters)\r\n\r\n  return response || alternative\r\n}\r\n\r\nexport {attempt as default}\r\n","import attempt from './attempt'\r\n\r\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {}\r\n\r\n  function cycle (key, value) {\r\n    if (value === copy) { return false }\r\n\r\n    if (typeof value === 'function') { return attempt(transform, value) }\r\n\r\n    if (typeof value === 'object') { return inject(value, transform) }\r\n\r\n    // return value;\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]) }\r\n\r\n  return copy\r\n}\r\n\r\nexport {inject as default}\r\n","/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\r\n\r\nexport {negated as default}\r\n","import inject from './inject'\r\nimport curry from './curry'\r\nimport negated from './negated'\r\n\r\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp\r\n\r\n  not = inject(it, negated)\r\n  not = inject(not, curry)\r\n  tmp = inject(it, curry)\r\n\r\n  tmp.not = not\r\n\r\n  return tmp\r\n}\r\n\r\nexport {prepare as default}\r\n","import equals from './equals'\r\nimport exists from './exists'\r\nimport prepare from './prepare'\r\n\r\nlet is = prepare({\r\n  element: (object) => {\r\n    return object.nodeType === document.ELEMENT_NODE\r\n  },\r\n\r\n  fragment: (object) => {\r\n    return object.nodeType === document.DOCUMENT_FRAGMENT_NODE\r\n  },\r\n\r\n  text: (object) => {\r\n    return object.nodeType === document.TEXT_NODE\r\n  },\r\n\r\n  equal: equals,\r\n  existant: exists\r\n})\r\n\r\nexport {is as default}\r\n","import attempt from './attempt'\r\n\r\n/**\r\n * Applies functions to a value and moves down the chain if possible\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array$\r\n *\r\n * @param {Array} array - list of functions to be applied\r\n * @param {Object} initial - optional initial item\r\n *\r\n * @return Object\r\n */\r\nfunction decompose (array, initial) {\r\n  let composer = (previous, current) => attempt(current, previous)\r\n  let reducer = (it) => array.reduce(composer, initial || it)\r\n\r\n  return initial ? reducer(initial) : reducer\r\n}\r\n\r\nexport {decompose as default}\r\n","import array from './array'\r\nimport pair from './pair'\r\nimport method from './curry'\r\nimport flatten from './flatten'\r\nimport decomposed from './decompose'\r\nimport attempt from './attempt'\r\n\r\nlet as = {\r\n  array,\r\n  pair,\r\n  method,\r\n  flatten,\r\n  decomposed,\r\n  attempt\r\n}\r\n\r\nexport {as as default}\r\n","/** module helpers */\r\nimport is from './is'\r\nimport as from './as'\r\n\r\nexport {is, as}\r\n"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","curry","method","transform","params","context","input","args","arguments","some","apply","has","object","property","hasOwnProperty","pair","Object","keys","map","key","value","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","equals","r","o","every","item","exists","attempt","mutation","subject","parameters","alternative","response","inject","copy","cycle","negated","prepare","not","tmp","is","nodeType","document","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","decompose","initial","composer","previous","current","reducer","as"],"mappings":"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"}