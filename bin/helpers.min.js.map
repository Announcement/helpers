{"version":3,"sources":["C:/Users/Francis/Documents/Projects/helpers/src/combine.js","C:/Users/Francis/Documents/Projects/helpers/src/array.js","C:/Users/Francis/Documents/Projects/helpers/src/curry.js","C:/Users/Francis/Documents/Projects/helpers/src/pair.js","C:/Users/Francis/Documents/Projects/helpers/src/flatten.js","C:/Users/Francis/Documents/Projects/helpers/src/equals.js","C:/Users/Francis/Documents/Projects/helpers/src/exists.js","C:/Users/Francis/Documents/Projects/helpers/src/attempt.js","C:/Users/Francis/Documents/Projects/helpers/src/inject.js","C:/Users/Francis/Documents/Projects/helpers/src/negated.js","C:/Users/Francis/Documents/Projects/helpers/src/prepare.js","C:/Users/Francis/Documents/Projects/helpers/src/inside.js","C:/Users/Francis/Documents/Projects/helpers/src/decompose.js","C:/Users/Francis/Documents/Projects/helpers/src/has.js","C:/Users/Francis/Documents/Projects/helpers/src/is.js","C:/Users/Francis/Documents/Projects/helpers/src/as.js","C:/Users/Francis/Documents/Projects/helpers/src/helpers.js"],"names":["combine","array","values","index","concat","indexOf","undefined","length","shift","it","Array","prototype","slice","call","curry","method","transform","params","context","input","_len","_key","arguments","args","this","some","apply","pair","object","Object","keys","map","key","value","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","equals","r","o","_typeof","every","item","has","exists","attempt","mutation","subject","parameters","alternative","response","inject","cycle","copy","negated","prepare","not","tmp","inside","haystack","needle","toValues","isObject","areInside","insideArray","insideObject","decompose","initial","composer","previous","current","reducer","property","hasOwnProperty","element","nodeType","document","ELEMENT_NODE","fragment","DOCUMENT_FRAGMENT_NODE","text","TEXT_NODE","is","as","are"],"mappings":"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","file":"helpers.min.js","sourcesContent":["/**\r\n * Appends values to an Array,\r\n * but first replaces undefined values before adding to the end\r\n *\r\n * @function combine\r\n *\r\n * @param {Array} array - list of existing items\r\n * @param {Array} values - proposed additions to the lsit\r\n *\r\n * @return {Array} - collective array\r\n */\r\nfunction combine (array, values) {\r\n  let index\r\n\r\n  array = array.concat([])\r\n\r\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\r\n    array[index] = values.shift()\r\n  }\r\n\r\n  return array.concat(values)\r\n}\r\n\r\nexport {combine as default}\r\n","/**\r\n * Lazy way of turning an item into an Array\r\n * @function array\r\n *\r\n * @param {Object} it - Array like object\r\n *\r\n * @return {Array} - implicit array object\r\n */\r\nfunction array (it) {\r\n  return Array.prototype.slice.call(it, 0)\r\n}\r\n\r\nexport {array as default}\r\n","import combine from './combine'\r\nimport array from './array'\r\n\r\n/**\r\n * Returns a modified function with lazy option assocations\r\n *\r\n * @function curry\r\n *\r\n * @param {Function} method - function to be curried\r\n *\r\n * @return {Function} curried functions\r\n */\r\nfunction curry (method) {\r\n  /**\r\n  * Generated method through currying, allowing chainibility\r\n  * @function transform\r\n  *\r\n  * @see combine\r\n  * @this\r\n  *\r\n  * @param {Array} params - arguments array\r\n  *\r\n  * @return {Object} piped output from source curry method\r\n  */\r\n  function transform (params) {\r\n    let context\r\n\r\n    return function (...input) {\r\n      let args = combine(params, array(arguments))\r\n\r\n      context = context || this\r\n\r\n      if (args.length < method.length || args.some((it) => it === undefined)) {\r\n        return transform(args)\r\n      } else {\r\n        return method.apply(context, args)\r\n      }\r\n    }\r\n  }\r\n  return method.length <= 1 ? method : transform([])\r\n}\r\n\r\nexport {curry as default}\r\n","/**\r\n * Pairs an object into a set of {key, value} arrays\r\n *\r\n * @function pair\r\n *\r\n * @param {Object} object - collection to be paired\r\n *\r\n * @return {Array.<{name: string, value}>}\r\n */\r\nfunction pair (object) {\r\n  return Object.keys(object).map((key) => {\r\n    return {key: key, value: object[key]}\r\n  })\r\n}\r\n\r\nexport {pair as default}\r\n","/**\r\n * Recursively brings arrays to the highest level\r\n *\r\n * @function flatten\r\n *\r\n * @param {Array.<Array>} array - container of the set\r\n *\r\n * @return Array\r\n */\r\nfunction flatten (array) {\r\n  let isArray\r\n  let toArray\r\n  let fromArray\r\n\r\n  isArray = (it) => it.constructor === Array\r\n  toArray = (it) => isArray(it) ? it : [it]\r\n  fromArray = (a, b) => a.concat(b)\r\n\r\n  while (array.some(isArray)) {\r\n    array = array.map(toArray).reduce(fromArray)\r\n  }\r\n\r\n  return array\r\n}\r\n\r\nexport {flatten as default}\r\n","import has from './has'\r\nimport pair from './pair'\r\nimport flatten from './flatten'\r\n\r\n/**\r\n * Compares reference object to another object\r\n *\r\n * @function equals\r\n *\r\n * @see has\r\n * @see pair\r\n *\r\n * @param {Object} reference - what should be compared to\r\n * @param {Object} object - what we are comparing\r\n *\r\n * @return {boolean}\r\n */\r\nfunction equals (r, o) {\r\n  // Are they of the same type?\r\n  if (typeof r !== typeof o || r.constructor !== o.constructor) {\r\n    return false\r\n  }\r\n\r\n  // Do we need to check recursively?\r\n  if (r.constructor !== Object) {\r\n    return r === o\r\n  }\r\n\r\n  return flatten([\r\n    pair(r),\r\n    pair(o)\r\n  ])\r\n  .every(item => {\r\n    return has(r)(item.key) &&\r\n      has(o)(item.key) &&\r\n      equals(r[item.key], o[item.key])\r\n  })\r\n}\r\n\r\nexport {equals as default}\r\n","/**\r\n * Checks to see if an item exists (isn't null or undefined)\r\n * @function exists\r\n *\r\n * @param {Object} it - the item in question of existance\r\n *\r\n * @return {boolean}\r\n */\r\nexport default function exists (it) {\r\n  return it !== undefined && it !== null\r\n}\r\n","import array from './array'\r\n\r\n/**\r\n * Attempts to apply mutation to subject, return unmodified on failure\r\n *\r\n * @function attempt\r\n *\r\n * @see array\r\n *\r\n * @param {Function} mutation - mutator function to be called on the subject\r\n * @param {Object} subject - any input that should be mutated\r\n *\r\n * @return {Object}\r\n */\r\nfunction attempt (mutation, subject) {\r\n  let parameters\r\n  let alternative\r\n  let response\r\n\r\n  parameters = array(arguments).slice(1)\r\n  alternative = parameters.length === 1 ? parameters[0] : parameters\r\n\r\n  response = mutation.apply(this, parameters)\r\n\r\n  return response || alternative\r\n}\r\n\r\nexport {attempt as default}\r\n","import attempt from './attempt'\r\n\r\n/**\r\n * Injects a transformer into each element of a collection\r\n *\r\n * @name inject(it, transformer)\r\n *\r\n * @see attempt\r\n *\r\n * @param {Object} it - collection\r\n * @param {Function} tranform - mutator function\r\n *\r\n * @return {Object.<string, Function>}\r\n */\r\nfunction inject (it, transform) {\r\n  let copy = {}\r\n\r\n  function cycle (key, value) {\r\n    if (value === copy) { return false }\r\n\r\n    if (typeof value === 'function') { return attempt(transform, value) }\r\n\r\n    if (typeof value === 'object') { return inject(value, transform) }\r\n\r\n    // return value;\r\n  }\r\n\r\n  for (let key in it) { copy[key] = cycle(key, it[key]) }\r\n\r\n  return copy\r\n}\r\n\r\nexport {inject as default}\r\n","/**\r\n * Returns a modified version of a function with negated boolean output\r\n *\r\n * @function negated\r\n *\r\n * @param {Function} it - method to be negated\r\n *\r\n * @return {Function}\r\n */\r\nfunction negated (it) {\r\n  return function () {\r\n    return !it.apply(this, arguments)\r\n  }\r\n}\r\n\r\nexport {negated as default}\r\n","import inject from './inject'\r\nimport curry from './curry'\r\nimport negated from './negated'\r\n\r\n/**\r\n * Prepares function collection by currying and adding a not chain\r\n *\r\n * @name prepare(it)\r\n *\r\n * @see inject\r\n * @see negated$\r\n * @see curry$\r\n *\r\n * @param {Object.<string, Function>} it - collection of functions\r\n *\r\n * @return {Object.<string, Function>} - curried functions object\r\n */\r\nfunction prepare (it) {\r\n  let not, tmp\r\n\r\n  not = inject(it, negated)\r\n  not = inject(not, curry)\r\n  tmp = inject(it, curry)\r\n\r\n  tmp.not = not\r\n\r\n  return tmp\r\n}\r\n\r\nexport {prepare as default}\r\n","/**\r\n * Detects if the needle is in the haystack.\r\n * @function inside\r\n *\r\n * @param {Object|Array} haystack - what we are looking in\r\n * @param {Object} needle - strict equal comparison compatible\r\n *\r\n * @return {Boolean} Whether or not the value could be located\r\n */\r\nfunction inside (haystack, needle) {\r\n  let toValues = object => key => object[key]\r\n  let isArray = it => it instanceof Array\r\n  let isObject = it => typeof it === 'object'\r\n  let values = it => Object.keys(it).map(toValues(it))\r\n\r\n  let areInside = it => inside(it, needle)\r\n\r\n  let insideArray = () => haystack.some(areInside)\r\n  let insideObject = () => values(haystack).some(areInside)\r\n\r\n  return haystack === needle ||\r\n    isArray(haystack) && insideArray(haystack, needle) ||\r\n    isObject(haystack) && insideObject(haystack, needle)\r\n}\r\n\r\n// exports.inside = inside\r\n\r\nexport {inside as default}\r\n","import attempt from './attempt'\r\n\r\n/**\r\n * Applies functions to a value and moves down the chain if possible\r\n *\r\n * @function decompose\r\n *\r\n * @see exists\r\n * @see attempt\r\n * @see array$\r\n *\r\n * @param {Array} array - list of functions to be applied\r\n * @param {Object} initial - optional initial item\r\n *\r\n * @return Object\r\n */\r\nfunction decompose (array, initial) {\r\n  let composer = (previous, current) => attempt(current, previous)\r\n  let reducer = (it) => array.reduce(composer, initial || it)\r\n\r\n  return initial ? reducer(initial) : reducer\r\n}\r\n\r\nexport {decompose as default}\r\n","import curry from './curry'\r\n\r\n/**\r\n * Curried shortcut to hasOwnProperty\r\n *\r\n * @function has\r\n *\r\n * @param {Object} object - collection containing property\r\n * @param {String} property - property name to be checked\r\n *\r\n * @return {boolean}\r\n */\r\n\r\nlet has = curry((object, property) => {\r\n  return object.hasOwnProperty(property)\r\n})\r\n\r\nexport {has as default}\r\n","import equals from './equals'\r\nimport exists from './exists'\r\nimport prepare from './prepare'\r\nimport inside from './inside'\r\n\r\nlet element = it =>\r\n  it.nodeType === document.ELEMENT_NODE\r\n\r\nlet fragment = it =>\r\n  it.nodeType === document.DOCUMENT_FRAGMENT_NODE\r\n\r\nlet text = it =>\r\n  it.nodeType === document.TEXT_NODE\r\n\r\nlet is = prepare({\r\n  element,\r\n  fragment,\r\n  text,\r\n  inside,\r\n  equal: equals,\r\n  existent: exists\r\n})\r\n\r\nexport {\r\n  is as default,\r\n  element,\r\n  fragment,\r\n  text,\r\n  equals as equal,\r\n  exists as existent\r\n}\r\n","import array from './array'\r\nimport pair from './pair'\r\nimport method from './curry'\r\nimport flatten from './flatten'\r\nimport decomposed from './decompose'\r\nimport attempt from './attempt'\r\n\r\nlet as = {\r\n  array,\r\n  pair,\r\n  method,\r\n  flatten,\r\n  decomposed,\r\n  attempt\r\n}\r\n\r\nexport {\r\n  as as default,\r\n  array,\r\n  pair,\r\n  method,\r\n  flatten,\r\n  decomposed,\r\n  attempt\r\n}\r\n","/** module helpers */\r\nimport * as is from './is'\r\nimport * as as from './as'\r\n\r\n// let helpers = {is, as}\r\nconst are = is\r\nexport {is, are, as}\r\n  // clone,\r\n  // combine,\r\n  // has,\r\n  // inject,\r\n  // negated,\r\n  // prepare\r\n"]}